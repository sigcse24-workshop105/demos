1
00:00:00,000 --> 00:00:02,680


2
00:00:02,680 --> 00:00:03,680
CARTER ZENKE: All right.

3
00:00:03,680 --> 00:00:04,840
Well hello, everyone.

4
00:00:04,840 --> 00:00:06,440
It is so wonderful to see you.

5
00:00:06,440 --> 00:00:07,790
My name is Carter Zenke.

6
00:00:07,790 --> 00:00:09,470
And I am the course's preceptor.

7
00:00:09,470 --> 00:00:11,247
I'm joined here by all of you all.

8
00:00:11,247 --> 00:00:13,580
So all that we do is just
take a minute to unmute and do

9
00:00:13,580 --> 00:00:17,610
something unusual for Zoom, which
is say hello all at the same time.

10
00:00:17,610 --> 00:00:21,800
So on the count of three, I'd like to
invite you to unmute and say hello.

11
00:00:21,800 --> 00:00:25,325
One, two, three, and

12
00:00:25,325 --> 00:00:27,753
AUDIENCE: (IN UNISON) Hello!

13
00:00:27,753 --> 00:00:28,670
CARTER ZENKE: Amazing.

14
00:00:28,670 --> 00:00:32,060
So it's good to have this nice
chorus of voices here today.

15
00:00:32,060 --> 00:00:34,880
Everything we'll do today is
here at this URL right here,

16
00:00:34,880 --> 00:00:37,367
CarterZenke.me/section.

17
00:00:37,367 --> 00:00:39,200
You'll find all of the
slides we'll work on.

18
00:00:39,200 --> 00:00:40,850
The exercises we'll work on together.

19
00:00:40,850 --> 00:00:42,933
If you like to get in touch
with me in particular,

20
00:00:42,933 --> 00:00:45,590
you can email me at
Carter@cs50.harvard.edu

21
00:00:45,590 --> 00:00:48,150
and feel free to email me there.

22
00:00:48,150 --> 00:00:52,140
So I thought we'd start off with, it's
just a kind of refresher on lecture.

23
00:00:52,140 --> 00:00:55,580
And so I invite you to think back
to two questions from this week's

24
00:00:55,580 --> 00:00:56,520
past lecture.

25
00:00:56,520 --> 00:00:59,810
The first is, what did you
find exciting from lecture?

26
00:00:59,810 --> 00:01:01,160
What are you interested in?

27
00:01:01,160 --> 00:01:04,550
And next is, what are you
still confused about or what

28
00:01:04,550 --> 00:01:06,240
do you still have questions about?

29
00:01:06,240 --> 00:01:09,270
So take a minute to think about
those two questions, again,

30
00:01:09,270 --> 00:01:12,390
what are you excited about and what
you still have questions about?

31
00:01:12,390 --> 00:01:14,700
And we'll come back in
maybe 30 seconds or so

32
00:01:14,700 --> 00:01:17,070
and share out a few of these ideas here.

33
00:01:17,070 --> 00:01:19,370
So we'll come back in 30 seconds.

34
00:01:19,370 --> 00:01:31,645


35
00:01:31,645 --> 00:01:38,513
[MUSIC PLAYING] (SINGING) Need to close
your eyes here too, and I at the time

36
00:01:38,513 --> 00:01:41,459
doesn't matter, we don't
care about the others.

37
00:01:41,459 --> 00:01:43,914
You stay on my mind because
you know you're my lover.

38
00:01:43,914 --> 00:01:47,842
Oh, baby you'll love it
and I can't ignore it.

39
00:01:47,842 --> 00:01:53,243
A light and you can notice,
my body gets carried away.

40
00:01:53,243 --> 00:01:56,680
I know what it is, yeah.

41
00:01:56,680 --> 00:02:01,090
You know the feel of me.

42
00:02:01,090 --> 00:02:01,590
All right.

43
00:02:01,590 --> 00:02:02,100
All right.

44
00:02:02,100 --> 00:02:04,620
And I don't want to leave.

45
00:02:04,620 --> 00:02:08,018
Talk, tell me maybe what you would do.

46
00:02:08,018 --> 00:02:09,470
Dance, dance.

47
00:02:09,470 --> 00:02:11,890
And wear your feeling's high.

48
00:02:11,890 --> 00:02:12,858
So hot.

49
00:02:12,858 --> 00:02:13,826
So hot, so hot.

50
00:02:13,826 --> 00:02:19,560


51
00:02:19,560 --> 00:02:20,560
CARTER ZENKE: All right.

52
00:02:20,560 --> 00:02:23,643
So I think that'll be enough time to
do some thinking on this past lecture

53
00:02:23,643 --> 00:02:24,220
this week.

54
00:02:24,220 --> 00:02:26,440
I hope you don't mind if
we do a few warm/cold calls

55
00:02:26,440 --> 00:02:28,440
to get a feel for what
we're interested in, what

56
00:02:28,440 --> 00:02:29,900
we're wondering about this week.

57
00:02:29,900 --> 00:02:32,260
So if you wouldn't mind, can I
go to maybe Elena and ask you

58
00:02:32,260 --> 00:02:35,135
what you find exciting, what you
are still wondering about this week?

59
00:02:35,135 --> 00:02:41,400


60
00:02:41,400 --> 00:02:46,160
AUDIENCE: So I think this week,
something that was pretty interesting

61
00:02:46,160 --> 00:02:50,880
was I thought the section about
debugging was pretty interesting.

62
00:02:50,880 --> 00:02:55,160
I definitely had to do a
lot of that for my presit.

63
00:02:55,160 --> 00:02:59,760
I'm not really wondering
so much so far, I think.

64
00:02:59,760 --> 00:03:03,663
I think we kind of just getting
intro to things, but yeah.

65
00:03:03,663 --> 00:03:05,330
CARTER ZENKE: Yeah, that's good to hear.

66
00:03:05,330 --> 00:03:07,470
So some interesting
debugging and how we do that.

67
00:03:07,470 --> 00:03:10,550
Well, I think we'll do a little
bit of that today in section,

68
00:03:10,550 --> 00:03:14,270
write some programs and hopefully
de-bug the errors we'll find in them

69
00:03:14,270 --> 00:03:16,993
and maybe could we go to
Dewey, if you don't mind.

70
00:03:16,993 --> 00:03:19,910
Maybe something you're interested
in or things you're wondering about?

71
00:03:19,910 --> 00:03:21,410
AUDIENCE: Yeah, no problem.

72
00:03:21,410 --> 00:03:25,790
I guess, like, the most interesting
thing from the lecture this week

73
00:03:25,790 --> 00:03:28,650
was actually the command line arguments.

74
00:03:28,650 --> 00:03:32,930
So I've programmed before, but I've
never actually used command line

75
00:03:32,930 --> 00:03:36,740
arguments in a program that I've made.

76
00:03:36,740 --> 00:03:39,570
So that was actually really cool.

77
00:03:39,570 --> 00:03:44,330
And then what I'm looking
forward to, I guess, just

78
00:03:44,330 --> 00:03:46,550
working on some more
complicated assignments

79
00:03:46,550 --> 00:03:48,180
because those tend to be quite fun.

80
00:03:48,180 --> 00:03:48,830
So yeah.

81
00:03:48,830 --> 00:03:49,430
CARTER ZENKE: Yeah, yeah.

82
00:03:49,430 --> 00:03:50,030
Very cool.

83
00:03:50,030 --> 00:03:55,190
So we saw command line arguments which,
again, are these inputs to your program

84
00:03:55,190 --> 00:03:58,310
that we can type in the terminal
itself before your program runs.

85
00:03:58,310 --> 00:04:01,250
And those then decide
how the program will run,

86
00:04:01,250 --> 00:04:04,940
gives it some options
to work with as it runs.

87
00:04:04,940 --> 00:04:06,950
Just a few questions for
us here today as well.

88
00:04:06,950 --> 00:04:09,050
Something we'll talk about
in section today are,

89
00:04:09,050 --> 00:04:11,210
what are the steps
involved in compilation?

90
00:04:11,210 --> 00:04:15,110
So we take the source code, this code
written in C and convert it to binary.

91
00:04:15,110 --> 00:04:18,269
But how do we do that
and why do we do that?

92
00:04:18,269 --> 00:04:20,570
We'll dive deeper into
arrays, what are they?

93
00:04:20,570 --> 00:04:21,740
Why would we use them?

94
00:04:21,740 --> 00:04:24,620
We'll talk about strings,
particularly in the context of arrays.

95
00:04:24,620 --> 00:04:28,670
And finally, to Dewey's point earlier,
we'll talk about command line arguments

96
00:04:28,670 --> 00:04:29,850
as well.

97
00:04:29,850 --> 00:04:33,440
And throughout this, we'll hope to
figure out what makes for good design.

98
00:04:33,440 --> 00:04:36,570
In this course, we'll
talk about correctness,

99
00:04:36,570 --> 00:04:39,080
which is, does your code
work, but also about design,

100
00:04:39,080 --> 00:04:40,880
which is how well does your code work?

101
00:04:40,880 --> 00:04:44,030
So we'll figure out what good design
looks like in a few different contexts

102
00:04:44,030 --> 00:04:45,380
here.

103
00:04:45,380 --> 00:04:47,750
Kick things off with compilation though.

104
00:04:47,750 --> 00:04:50,813
We saw this program in lecture,
if I can go to full screen here,

105
00:04:50,813 --> 00:04:53,480
and can have somebody just shout
out what would this program do?

106
00:04:53,480 --> 00:04:57,970
If I were to run this program,
what would you see on your screen?

107
00:04:57,970 --> 00:05:00,070
Maybe could I ask McKenna,
if you don't mind?

108
00:05:00,070 --> 00:05:01,060
Do a warm/cold call.

109
00:05:01,060 --> 00:05:03,790
AUDIENCE: Yeah, you were
just saying "hello, world".

110
00:05:03,790 --> 00:05:05,110
CARTER ZENKE: Yeah, just
saying "hello, world", right?

111
00:05:05,110 --> 00:05:06,280
And go back to this here.

112
00:05:06,280 --> 00:05:11,270
Now if we were to compile this
from C to machine code, to binary,

113
00:05:11,270 --> 00:05:12,770
we'd have a few steps along the way.

114
00:05:12,770 --> 00:05:13,790
So we saw this lecture.

115
00:05:13,790 --> 00:05:16,150
We saw that this source
code first gets converted

116
00:05:16,150 --> 00:05:20,500
to assembly code, this kind of esoteric
language here that isn't quite binary,

117
00:05:20,500 --> 00:05:22,100
but is almost there.

118
00:05:22,100 --> 00:05:25,690
And in the next step, we end
up getting down to this binary

119
00:05:25,690 --> 00:05:27,410
that your computer actually runs.

120
00:05:27,410 --> 00:05:30,520
So we have this maybe,
Hello.C file that then

121
00:05:30,520 --> 00:05:35,600
gets converted to this regular hello
file that's written in binary here.

122
00:05:35,600 --> 00:05:40,480
And to do this, we have this
program called Clang, or C-language,

123
00:05:40,480 --> 00:05:42,170
C-language compiler here.

124
00:05:42,170 --> 00:05:45,280
And if we were to run
Clang like this, we

125
00:05:45,280 --> 00:05:48,250
would probably need to provide
a little more context for Clang

126
00:05:48,250 --> 00:05:51,220
because Clang wants to
actually take some source code

127
00:05:51,220 --> 00:05:53,420
and convert it to machine code.

128
00:05:53,420 --> 00:05:57,020
But here, it wonders what source code
should I convert to machine code.

129
00:05:57,020 --> 00:05:59,260
So we might use an example
of a command line argument

130
00:05:59,260 --> 00:06:01,990
here and actually tell it
what we want to convert.

131
00:06:01,990 --> 00:06:07,420
We can type Clang hello.c to tell it we
want to convert this hello.c file down

132
00:06:07,420 --> 00:06:08,890
to binary.

133
00:06:08,890 --> 00:06:10,780
But we could also be more specific.

134
00:06:10,780 --> 00:06:13,707
We could say, I want
not just the a.out we

135
00:06:13,707 --> 00:06:16,540
would get from this we saw in
lecture, but more specifically, a file

136
00:06:16,540 --> 00:06:17,530
called "hello".

137
00:06:17,530 --> 00:06:21,130
So I could say "clang-o"
and then "hello"

138
00:06:21,130 --> 00:06:23,360
to say this is the output file I want.

139
00:06:23,360 --> 00:06:25,540
And then finally, the hello.c
file we would actually

140
00:06:25,540 --> 00:06:29,740
want to compile from source
code to machine code here.

141
00:06:29,740 --> 00:06:33,040
And all of this can get
a little bit complicated,

142
00:06:33,040 --> 00:06:37,540
this isn't the full command we need
to compile all of our saved programs.

143
00:06:37,540 --> 00:06:39,352
We might want to link in some libraries.

144
00:06:39,352 --> 00:06:41,560
And there's a lot of other
things you might type here

145
00:06:41,560 --> 00:06:43,430
to make your compilation successful.

146
00:06:43,430 --> 00:06:47,320
So what we've done is we've given you
this command called "make" that sort

147
00:06:47,320 --> 00:06:48,820
of simplifies a lot of that for you.

148
00:06:48,820 --> 00:06:51,160
So "make" runs in the background.

149
00:06:51,160 --> 00:06:53,710
Clang, along with a lot of
options behind the scenes

150
00:06:53,710 --> 00:06:56,175
to compile your program
to binary, ultimately.

151
00:06:56,175 --> 00:06:59,050
But in this class, and even if you
do more programming in the future,

152
00:06:59,050 --> 00:07:00,400
you'll probably use a
command called "make"

153
00:07:00,400 --> 00:07:04,010
to simplify that and keep yourself from
typing all this stuff in the terminal

154
00:07:04,010 --> 00:07:05,560
as you go.

155
00:07:05,560 --> 00:07:07,870
Now what questions do you
all have on compilation,

156
00:07:07,870 --> 00:07:10,390
or on converting from source
code to machine code, if any?

157
00:07:10,390 --> 00:07:16,000


158
00:07:16,000 --> 00:07:16,500
All right.

159
00:07:16,500 --> 00:07:18,300
So seeing none here,
and I imagine you've

160
00:07:18,300 --> 00:07:20,590
gotten to do this a little
bit so far in the class.

161
00:07:20,590 --> 00:07:24,180
So let's dive a little more
deeply into arrays now.

162
00:07:24,180 --> 00:07:28,050
So if we talk about converting
source code to machine code,

163
00:07:28,050 --> 00:07:30,420
getting down to like the low
level details of computer.

164
00:07:30,420 --> 00:07:34,620
And arrays themselves are the most
basic data structure we can have.

165
00:07:34,620 --> 00:07:37,420
The most basic way we
can organize our data.

166
00:07:37,420 --> 00:07:42,150
So I'm curious to hear your
thoughts on what is an array?

167
00:07:42,150 --> 00:07:43,740
What would you define as an array?

168
00:07:43,740 --> 00:07:46,320
And can we go maybe to
Bianca, if you don't mind?

169
00:07:46,320 --> 00:07:50,348
What in your mind is an array?

170
00:07:50,348 --> 00:07:50,890
AUDIENCE: OK.

171
00:07:50,890 --> 00:07:54,260
So this was the most confusing
part of lecture for me.

172
00:07:54,260 --> 00:08:00,070
But I think it compiles like--

173
00:08:00,070 --> 00:08:02,830
it's like smaller pieces
that are like elements,

174
00:08:02,830 --> 00:08:07,240
so it compiles all the
elements into essentially,

175
00:08:07,240 --> 00:08:10,460
so that they're all next to each other.

176
00:08:10,460 --> 00:08:19,210
And it also sorts, for lack of a
better term, elements of the same value

177
00:08:19,210 --> 00:08:21,408
so that they're next to each other.

178
00:08:21,408 --> 00:08:22,200
CARTER ZENKE: Yeah.

179
00:08:22,200 --> 00:08:23,620
So I like a few things
about what you said there.

180
00:08:23,620 --> 00:08:26,910
So I like that you said that it combines
these elements, these pieces of data

181
00:08:26,910 --> 00:08:27,780
that we have.

182
00:08:27,780 --> 00:08:30,760
And it puts them back to back in memory.

183
00:08:30,760 --> 00:08:33,510
So let's take a look at an example here.

184
00:08:33,510 --> 00:08:37,380
One CHT final project was
this one called SleepS50.

185
00:08:37,380 --> 00:08:39,690
And the goal of this project
was to actually store

186
00:08:39,690 --> 00:08:42,157
the number of hours somebody
has slept every day.

187
00:08:42,157 --> 00:08:44,490
So somebody might come back
to this application and type

188
00:08:44,490 --> 00:08:46,480
in, I slept eight hours last night.

189
00:08:46,480 --> 00:08:49,230
They come back the next day, they
type maybe nine hours, or seven,

190
00:08:49,230 --> 00:08:51,000
depending on how much they slept.

191
00:08:51,000 --> 00:08:56,160
And if we wanted to store this data,
at least currently in our story so far,

192
00:08:56,160 --> 00:08:58,830
we would need a whole
bunch of variables.

193
00:08:58,830 --> 00:09:02,795
We'd have to say, OK, I need hours
one, I need hours two, hours three

194
00:09:02,795 --> 00:09:04,920
and so on as that we're
going through the days here

195
00:09:04,920 --> 00:09:06,490
to store all of this data.

196
00:09:06,490 --> 00:09:11,380
But what is not so well
designed about this?

197
00:09:11,380 --> 00:09:12,840
Where would this go wrong?

198
00:09:12,840 --> 00:09:15,150
And maybe could I ask
Elena, if you don't mind?

199
00:09:15,150 --> 00:09:19,400


200
00:09:19,400 --> 00:09:21,302
AUDIENCE: I'm not too sure.

201
00:09:21,302 --> 00:09:22,010
CARTER ZENKE: OK.

202
00:09:22,010 --> 00:09:25,400
So we're trying to store
all this data, right?

203
00:09:25,400 --> 00:09:28,200
And if we had to keep track
of all of these variables,

204
00:09:28,200 --> 00:09:32,450
let's say I wanted to have a sixth day
of hours, what would I have to do now?

205
00:09:32,450 --> 00:09:36,880


206
00:09:36,880 --> 00:09:39,190
AUDIENCE: You have to add another line?

207
00:09:39,190 --> 00:09:42,970
CARTER ZENKE: Yeah, add another line
and presumably, another variable.

208
00:09:42,970 --> 00:09:45,850
But that would get pretty messy,
pretty quickly because assuming I

209
00:09:45,850 --> 00:09:48,580
want to keep track of maybe like
a whole year's worth of sleep,

210
00:09:48,580 --> 00:09:52,330
I wouldn't want to have
hours 1 through hours 365.

211
00:09:52,330 --> 00:09:55,690
That would just be a whole lot
of individual variables, right?

212
00:09:55,690 --> 00:09:59,200
And so to Bianca's point
earlier, these arrays

213
00:09:59,200 --> 00:10:02,840
help us keep track of this
information all in one piece.

214
00:10:02,840 --> 00:10:05,170
So let's take a look at an
example of an array here.

215
00:10:05,170 --> 00:10:07,870
Here we have one called "hours".

216
00:10:07,870 --> 00:10:09,730
And as we're thinking
about these arrays,

217
00:10:09,730 --> 00:10:14,930
this really good mental model is this
long line of individual pieces of data.

218
00:10:14,930 --> 00:10:20,050
So here we have those same five hours,
but now under one block of memory

219
00:10:20,050 --> 00:10:22,000
that we're going to call "hours".

220
00:10:22,000 --> 00:10:24,398
And when we're trying to
create this block of memory,

221
00:10:24,398 --> 00:10:27,440
there are really three things you're
going to need to take care of first.

222
00:10:27,440 --> 00:10:31,360
So the first one is
the name of this block.

223
00:10:31,360 --> 00:10:33,290
What are we going to call this array?

224
00:10:33,290 --> 00:10:35,380
So here, we're going to call it "hours".

225
00:10:35,380 --> 00:10:39,880
And maybe I'll turn it over to you all
for the other two that matter here.

226
00:10:39,880 --> 00:10:41,763
We have a name for the
array, but what else

227
00:10:41,763 --> 00:10:44,680
do we care about if we're going to
try to create this block of memory?

228
00:10:44,680 --> 00:10:45,888
Could I ask maybe you, Dewey?

229
00:10:45,888 --> 00:10:46,818
Yeah, go ahead.

230
00:10:46,818 --> 00:10:48,860
AUDIENCE: You would need
the length of the array.

231
00:10:48,860 --> 00:10:52,330
So here, we would probably want seven
because there are seven days in a week.

232
00:10:52,330 --> 00:10:53,920
CARTER ZENKE: Yes, so
probably seven days in a week.

233
00:10:53,920 --> 00:10:56,110
So we could make maybe
this array of length seven

234
00:10:56,110 --> 00:10:59,050
to store seven hours of sleep every day.

235
00:10:59,050 --> 00:11:02,650
In this case, we'll probably
just go with a week day calendar.

236
00:11:02,650 --> 00:11:04,558
So we'll have five in this case.

237
00:11:04,558 --> 00:11:06,850
But the size is certainly
something we care about here.

238
00:11:06,850 --> 00:11:10,990
And there's one other thing we
care about too, the name, the size,

239
00:11:10,990 --> 00:11:13,375
and what else would we need?

240
00:11:13,375 --> 00:11:16,280


241
00:11:16,280 --> 00:11:21,300
Could I maybe ask you, McKenna,
if you have any ideas here?

242
00:11:21,300 --> 00:11:23,000
AUDIENCE: I'm honestly not sure.

243
00:11:23,000 --> 00:11:24,000
CARTER ZENKE: That's OK.

244
00:11:24,000 --> 00:11:24,330
No worries.

245
00:11:24,330 --> 00:11:27,288
AUDIENCE: This is like a topic from
lecture I was a little confused on.

246
00:11:27,288 --> 00:11:28,730
CARTER ZENKE: Yeah, yeah.

247
00:11:28,730 --> 00:11:30,710
Other thoughts here?

248
00:11:30,710 --> 00:11:33,430


249
00:11:33,430 --> 00:11:38,113
AUDIENCE: The type of value?

250
00:11:38,113 --> 00:11:39,280
CARTER ZENKE: Yeah, totally.

251
00:11:39,280 --> 00:11:41,822
So we need the type that
we're actually storing here.

252
00:11:41,822 --> 00:11:44,280
So three things we care about
for arrays when we make them.

253
00:11:44,280 --> 00:11:49,530
The name, the size, how many elements
are we storing and then also what

254
00:11:49,530 --> 00:11:52,050
kind of type are we
storing in this array?

255
00:11:52,050 --> 00:11:56,730
And the type matters because we want
to know how much space to allocate

256
00:11:56,730 --> 00:11:57,887
to our array.

257
00:11:57,887 --> 00:12:00,720
Different types have different
numbers of bytes that represent them,

258
00:12:00,720 --> 00:12:05,970
like an integer might have 32 bits,
or maybe 4 bytes, in that case.

259
00:12:05,970 --> 00:12:10,560
But maybe just a character would
have only 8 bits, or one byte.

260
00:12:10,560 --> 00:12:12,450
So the type depends--

261
00:12:12,450 --> 00:12:16,980
the type matters for how much memory
we're going to allocate to our array

262
00:12:16,980 --> 00:12:18,250
here.

263
00:12:18,250 --> 00:12:22,230
So with this in mind, we keep in
mind the name, the size, the type.

264
00:12:22,230 --> 00:12:25,260
We have some syntax we would
use in C to actually create

265
00:12:25,260 --> 00:12:27,128
this space for the array.

266
00:12:27,128 --> 00:12:28,920
And this is what that
would look like here.

267
00:12:28,920 --> 00:12:33,870
Up top, we have "int" and what
would "int" represent in this case?

268
00:12:33,870 --> 00:12:36,450
Could I, maybe, go back to you, Dewey?

269
00:12:36,450 --> 00:12:38,980
What would "int" represent here?

270
00:12:38,980 --> 00:12:40,810
AUDIENCE: It would
represent the data type

271
00:12:40,810 --> 00:12:42,860
of the stuff stored inside the array.

272
00:12:42,860 --> 00:12:44,778
So we're storing integers
so we want "int".

273
00:12:44,778 --> 00:12:45,820
CARTER ZENKE: Yeah, nice.

274
00:12:45,820 --> 00:12:49,450
So similarly to how we declare
our variables with the type first,

275
00:12:49,450 --> 00:12:51,820
so similarly, for our arrays,
we say what type do you

276
00:12:51,820 --> 00:12:54,040
want to put in this array first?

277
00:12:54,040 --> 00:12:56,330
And then next is the name of the array.

278
00:12:56,330 --> 00:12:57,340
So "hours".

279
00:12:57,340 --> 00:13:00,670
And then what is inside these brackets?

280
00:13:00,670 --> 00:13:03,640
Maybe could I ask you, Bianca?

281
00:13:03,640 --> 00:13:06,700
Do you mind telling me
what's inside these brackets?

282
00:13:06,700 --> 00:13:08,470
What pieces of the puzzle is that?

283
00:13:08,470 --> 00:13:13,000


284
00:13:13,000 --> 00:13:15,650
AUDIENCE: That's the size of the array.

285
00:13:15,650 --> 00:13:17,690
CARTER ZENKE: Yeah, it's
the size of the array.

286
00:13:17,690 --> 00:13:20,630
So here, we're saying we
have an array called "hours"

287
00:13:20,630 --> 00:13:21,980
that will store integers.

288
00:13:21,980 --> 00:13:25,850
And it will be of size five,
so we'll store five integers.

289
00:13:25,850 --> 00:13:29,060
And this is all well and good,
but one thing to keep in mind

290
00:13:29,060 --> 00:13:33,620
is that our array isn't quite
useful unless we can access

291
00:13:33,620 --> 00:13:35,970
individual elements of the array.

292
00:13:35,970 --> 00:13:40,020
So we have this syntax that
also uses this bracket notation.

293
00:13:40,020 --> 00:13:43,435
And we can see it a little
bit down below here.

294
00:13:43,435 --> 00:13:46,310
So if we wanted to get the very
first element of our array, we'd say,

295
00:13:46,310 --> 00:13:48,320
hours[0].

296
00:13:48,320 --> 00:13:51,740
If we wanted to get the next one,
we'd say hours[1], and so on.

297
00:13:51,740 --> 00:13:55,190
And all the way at the end
here, we have hours[4].

298
00:13:55,190 --> 00:14:01,010
But why would we not have hours[5]
to get that last element there?

299
00:14:01,010 --> 00:14:03,173
How does that make sense?

300
00:14:03,173 --> 00:14:05,090
Maybe Elena, would you
have any thoughts here?

301
00:14:05,090 --> 00:14:07,160
McKenna, I see your hand raised.

302
00:14:07,160 --> 00:14:10,610
AUDIENCE: Well since we start
from 0, like if we want 5 pieces,

303
00:14:10,610 --> 00:14:15,083
if we count all the way up to hours[5],
then we actually have six pieces.

304
00:14:15,083 --> 00:14:16,250
CARTER ZENKE: Yeah, totally.

305
00:14:16,250 --> 00:14:20,750
So if we counted from 0 to 5 inclusive,
well, that's actually six elements.

306
00:14:20,750 --> 00:14:22,880
But we only have five in our array.

307
00:14:22,880 --> 00:14:26,240
If we start from 0 and count up to four,
well, that's five distinct elements.

308
00:14:26,240 --> 00:14:28,430
And so that is the length
of our array, meaning

309
00:14:28,430 --> 00:14:32,520
we're not going beyond the
length of our array here.

310
00:14:32,520 --> 00:14:36,500
And if we wanted to go ahead
and add some data to this array,

311
00:14:36,500 --> 00:14:38,310
it'd be a simple assignment.

312
00:14:38,310 --> 00:14:43,220
So here, I might say, I want to put
seven in the very first array spot.

313
00:14:43,220 --> 00:14:45,590
Hours[0] gets the value seven.

314
00:14:45,590 --> 00:14:49,850
Remember, we read this equal
sign as a "get" in English.

315
00:14:49,850 --> 00:14:54,110
And then we could say, OK well,
hours[1] should get the value 9

316
00:14:54,110 --> 00:14:55,590
and so on and so forth.

317
00:14:55,590 --> 00:14:57,680
And so we fill up our array as we go.

318
00:14:57,680 --> 00:14:59,620
Now we could fill up the
entire array at once,

319
00:14:59,620 --> 00:15:02,120
if we wanted to enough to have
all these lines of code here.

320
00:15:02,120 --> 00:15:03,630
We could do this.

321
00:15:03,630 --> 00:15:08,930
We could say, let's create this array
named "hours" that has five elements.

322
00:15:08,930 --> 00:15:13,760
And let's have it "get" this set
of numbers here, 7, 9, 8, 7, 8.

323
00:15:13,760 --> 00:15:17,270
And overall, that would give us the
entire array filled up for ourselves

324
00:15:17,270 --> 00:15:18,510
here.

325
00:15:18,510 --> 00:15:22,480
And even then, we might not even specify
the size in this case because we know,

326
00:15:22,480 --> 00:15:24,510
well, there are five elements over here.

327
00:15:24,510 --> 00:15:27,830
So we could just have C infer how
much space our array takes up.

328
00:15:27,830 --> 00:15:30,260
You take out that five
there and say, well, we just

329
00:15:30,260 --> 00:15:34,523
have these five elements here, we'll
make sure we have an array of size 5.

330
00:15:34,523 --> 00:15:36,440
So I just want to pause
here for any questions

331
00:15:36,440 --> 00:15:39,800
you all might have on this array
syntax, or how arrays are working here?

332
00:15:39,800 --> 00:15:50,600


333
00:15:50,600 --> 00:15:51,910
All right.

334
00:15:51,910 --> 00:15:54,410
So seeing none so far.

335
00:15:54,410 --> 00:15:57,590
Let's keep going then and get
to an exercise in just a bit.

336
00:15:57,590 --> 00:16:01,570
One thing we might want to do with our
arrays is, again, access each element.

337
00:16:01,570 --> 00:16:05,320
And sometimes, we want to
start at the very first element

338
00:16:05,320 --> 00:16:08,350
and then keep accessing
things as we go through.

339
00:16:08,350 --> 00:16:10,960
And a for loop is a great way
to do that because a for loop

340
00:16:10,960 --> 00:16:15,110
lets us specify a variable
that can increase.

341
00:16:15,110 --> 00:16:19,550
And we can then use that variable to
access individual parts of our array.

342
00:16:19,550 --> 00:16:23,290
So here, I might have the
same array, "hours" up at top.

343
00:16:23,290 --> 00:16:26,440
And now this for loop
here, that is starting at I

344
00:16:26,440 --> 00:16:31,960
equals 0, going up to, but not
including I will be equal to 5.

345
00:16:31,960 --> 00:16:35,950
And then we'll go ahead and print
out whatever is at hours[i] here.

346
00:16:35,950 --> 00:16:38,200
And so a question for the
group now is what would this

347
00:16:38,200 --> 00:16:40,820
print out if I were to run this?

348
00:16:40,820 --> 00:16:42,100
What would I see on my screen?

349
00:16:42,100 --> 00:16:44,058
And feel free to raise
your hand if you'd like.

350
00:16:44,058 --> 00:16:49,748


351
00:16:49,748 --> 00:16:52,040
What would I see on my screen
for to run this for loop?

352
00:16:52,040 --> 00:16:54,146
Yeah, Dewey?

353
00:16:54,146 --> 00:16:58,390
AUDIENCE: You would see and, then a
new line, 9, new line, 8, and then

354
00:16:58,390 --> 00:17:00,250
onwards until the end of the list--

355
00:17:00,250 --> 00:17:01,608
array, technically. yeah.

356
00:17:01,608 --> 00:17:02,650
CARTER ZENKE: Yeah, yeah.

357
00:17:02,650 --> 00:17:06,310
And I'm curious, you said a new line,
so what is indicative of the new line

358
00:17:06,310 --> 00:17:07,329
here?

359
00:17:07,329 --> 00:17:08,349
There's a slash, n.

360
00:17:08,349 --> 00:17:12,040
So that means-- that tells the
computer to start a new line.

361
00:17:12,040 --> 00:17:15,069
CARTER ZENKE: Right, so in this print
statement here, we have that %i,

362
00:17:15,069 --> 00:17:18,040
which is like a placeholder for
an integer that will print out.

363
00:17:18,040 --> 00:17:22,450
And we'll specifically add in the
hours bracket I integer there.

364
00:17:22,450 --> 00:17:25,660
And we'll make a new line here to say,
OK, once you're printing that integer,

365
00:17:25,660 --> 00:17:27,952
let's go to a new line, print
that one, go to new line,

366
00:17:27,952 --> 00:17:32,510
print that one and so on
and so forth right here.

367
00:17:32,510 --> 00:17:36,610
So with that in mind, let's
go ahead and try and exercise

368
00:17:36,610 --> 00:17:38,230
in small breakout rooms here.

369
00:17:38,230 --> 00:17:40,840
And this exercise is called powers of 2.

370
00:17:40,840 --> 00:17:45,460
So the goal here is to make an
array that has a certain size, maybe

371
00:17:45,460 --> 00:17:47,480
given to us by the user.

372
00:17:47,480 --> 00:17:51,790
And then we'll want to create
an array where every element is

373
00:17:51,790 --> 00:17:53,770
2 times the previous number.

374
00:17:53,770 --> 00:17:57,460
And we can start the array at one.

375
00:17:57,460 --> 00:18:03,640
So we might have an array like,
1, 2, 4, 8, 16, 32 and increasing

376
00:18:03,640 --> 00:18:07,557
by two times every time we go through
and add this new element here.

377
00:18:07,557 --> 00:18:09,890
And let's go ahead and get
started on this one together.

378
00:18:09,890 --> 00:18:14,480
So if you want to ahead and pull up
code.csu.io, that would be great.

379
00:18:14,480 --> 00:18:17,740
And you can follow along over
here while mine boots up as well.

380
00:18:17,740 --> 00:18:20,470


381
00:18:20,470 --> 00:18:24,030
And what we'll do once your code
space loads is create this file

382
00:18:24,030 --> 00:18:27,120
called array.c.

383
00:18:27,120 --> 00:18:29,820
Go ahead and make this
program where we'll

384
00:18:29,820 --> 00:18:35,350
have this array that will be every
element two times the previous one.

385
00:18:35,350 --> 00:18:40,000
And just to kick us off here
in a discussion, what kind

386
00:18:40,000 --> 00:18:42,890
of boilerplate code would
we really need here,

387
00:18:42,890 --> 00:18:46,930
and by boilerplate, I mean default
code we want to have in every program

388
00:18:46,930 --> 00:18:47,688
that we write?

389
00:18:47,688 --> 00:18:50,605
Maybe at the top of our file, what's
the first thing we would do here?

390
00:18:50,605 --> 00:18:56,950


391
00:18:56,950 --> 00:19:00,847
Can I ask maybe Sotanalie,
if you don't mind?

392
00:19:00,847 --> 00:19:03,555
What would we have to have the
top of every area of our programs?

393
00:19:03,555 --> 00:19:10,380


394
00:19:10,380 --> 00:19:12,720
And I'll have mine booted up here.

395
00:19:12,720 --> 00:19:17,690
So what we want to do very first is
make sure we have our program up.

396
00:19:17,690 --> 00:19:21,230
So we can type code array.c.

397
00:19:21,230 --> 00:19:25,010
And that will make sure we have
this new file called array.c.

398
00:19:25,010 --> 00:19:26,540
And that ".c" is important there.

399
00:19:26,540 --> 00:19:28,700
That means this is a C file.

400
00:19:28,700 --> 00:19:31,640
And now at the very top of our
programs, what we're going to need?

401
00:19:31,640 --> 00:19:34,490
Can I maybe turn to
Elena, If you don't mind?

402
00:19:34,490 --> 00:19:37,730
What would we want to incorporate the
very top of our file in most programs

403
00:19:37,730 --> 00:19:40,370
we write?

404
00:19:40,370 --> 00:19:45,350
AUDIENCE: You would have
to include from the one,

405
00:19:45,350 --> 00:19:53,000
the packages, like,
from like CS50 and ST--

406
00:19:53,000 --> 00:19:53,968
I forgot it.

407
00:19:53,968 --> 00:19:55,010
CARTER ZENKE: Yeah, yeah.

408
00:19:55,010 --> 00:19:55,885
You're totally right.

409
00:19:55,885 --> 00:19:59,420
So we want to make sure we include
some libraries or some packages

410
00:19:59,420 --> 00:20:01,970
perhaps in our program
because we actually

411
00:20:01,970 --> 00:20:03,650
use those functions in our program.

412
00:20:03,650 --> 00:20:09,620
So we might first include the
CS50 library by #include CS50.h.

413
00:20:09,620 --> 00:20:13,220
And we might also want to
include the standard I/O library.

414
00:20:13,220 --> 00:20:16,160
The first standard input and
output, meaning some functions

415
00:20:16,160 --> 00:20:21,530
we can use to get user input and then
print something out to the screen here.

416
00:20:21,530 --> 00:20:26,030
And then what else would we
need, kind of template here?

417
00:20:26,030 --> 00:20:31,280
What kind of function is going to be
the core part of our program here?

418
00:20:31,280 --> 00:20:32,832
How would we do that?

419
00:20:32,832 --> 00:20:33,665
Could I ask McKenna?

420
00:20:33,665 --> 00:20:37,760


421
00:20:37,760 --> 00:20:39,110
I'm so sorry.

422
00:20:39,110 --> 00:20:43,673
For the core part of our program,
we would need main void, right?

423
00:20:43,673 --> 00:20:44,840
CARTER ZENKE: Yeah, totally.

424
00:20:44,840 --> 00:20:45,507
"Int main void".

425
00:20:45,507 --> 00:20:48,470
So I could type "int
main(void)" here and then

426
00:20:48,470 --> 00:20:52,190
have this to dileanate where I'm
going to type the rest of my program

427
00:20:52,190 --> 00:20:54,410
inside of these curly braces here.

428
00:20:54,410 --> 00:20:57,740
And we'll see why in particular, we
type "int main(void)" just a little bit.

429
00:20:57,740 --> 00:20:59,600
We saw it briefly in lecture two.

430
00:20:59,600 --> 00:21:05,040
But for now, we want to make sure that
we're going to get some user input.

431
00:21:05,040 --> 00:21:08,510
So I might have you all
finish this part together

432
00:21:08,510 --> 00:21:12,290
before sending you off to work on
the actual array building piece.

433
00:21:12,290 --> 00:21:17,010
But what kind of function would we
use to get user input in this case?

434
00:21:17,010 --> 00:21:21,420
We want to get a number that we could
use for the length of our array.

435
00:21:21,420 --> 00:21:26,430
So what kind of function have we seen
in CS50 that could help us with that?

436
00:21:26,430 --> 00:21:30,380
Do you mind if I ask maybe Bianca if
you have an idea, or maybe some steps

437
00:21:30,380 --> 00:21:32,025
forward for us?

438
00:21:32,025 --> 00:21:33,650
AUDIENCE: Can you repeat what you said?

439
00:21:33,650 --> 00:21:34,580
I'm sorry.

440
00:21:34,580 --> 00:21:35,622
CARTER ZENKE: Yeah, yeah.

441
00:21:35,622 --> 00:21:39,210
So we want to make sure we have user
input to get the length of the array.

442
00:21:39,210 --> 00:21:42,680
So what kind of function could we
use to get a number from the unit

443
00:21:42,680 --> 00:21:44,490
that we've seen so far?

444
00:21:44,490 --> 00:21:45,800
AUDIENCE: A number you said?

445
00:21:45,800 --> 00:21:46,970
CARTER ZENKE: A number.

446
00:21:46,970 --> 00:21:48,450
AUDIENCE: The "get int".

447
00:21:48,450 --> 00:21:49,700
CARTER ZENKE: Yeah, "get int".

448
00:21:49,700 --> 00:21:54,110
So we could say I want to maybe
create the length of this array

449
00:21:54,110 --> 00:21:57,110
and I want to make sure I
get an "int" from the user,

450
00:21:57,110 --> 00:22:01,130
maybe prompt them for a length, right?

451
00:22:01,130 --> 00:22:04,880
And here's a question of design.

452
00:22:04,880 --> 00:22:07,000
What if these are typed
in a negative number?

453
00:22:07,000 --> 00:22:10,580
Well, I can't have a
negative length array

454
00:22:10,580 --> 00:22:13,780
so I should probably do my best to
make sure they give me a good number

455
00:22:13,780 --> 00:22:15,320
and not assume that
they're going to cooperate.

456
00:22:15,320 --> 00:22:16,112
So I might do this.

457
00:22:16,112 --> 00:22:21,010
I could say, "do", I want to make sure
that I get the length from the user

458
00:22:21,010 --> 00:22:22,430
here.

459
00:22:22,430 --> 00:22:25,370
And I'll make sure to
declare my variable up above.

460
00:22:25,370 --> 00:22:28,670
But then before moving
on, I want to make sure

461
00:22:28,670 --> 00:22:33,140
that this length is definitely
going to be at least one.

462
00:22:33,140 --> 00:22:35,600
So I'll say if the
length is less than 1,

463
00:22:35,600 --> 00:22:38,350
I want to re-prompt the
user as we go through.

464
00:22:38,350 --> 00:22:40,100
This just ensures that
you just don't type

465
00:22:40,100 --> 00:22:44,090
in negative 1 or 0, like values that
are invalid for our right length.

466
00:22:44,090 --> 00:22:47,220


467
00:22:47,220 --> 00:22:49,920
So we have some initial
code here and feel free

468
00:22:49,920 --> 00:22:53,730
to jot this down on
your own array.c file.

469
00:22:53,730 --> 00:22:56,550
But we'll do next is we'll
break out into a few rooms

470
00:22:56,550 --> 00:22:58,830
and we'll come back in
maybe five minutes or so.

471
00:22:58,830 --> 00:23:02,290
But the goal here will be
to finish this prompt here.

472
00:23:02,290 --> 00:23:06,090
So you're going to create an array that
is of size, whatever the user typed in.

473
00:23:06,090 --> 00:23:10,200
And then we'll make sure that every
number is two times the previous one.

474
00:23:10,200 --> 00:23:11,490
Yeah, Dewey?

475
00:23:11,490 --> 00:23:13,950
AUDIENCE: Would it be possible
for you to copy and paste

476
00:23:13,950 --> 00:23:17,738
the prompt into the chat
so that we have it on hand?

477
00:23:17,738 --> 00:23:18,780
CARTER ZENKE: Absolutely.

478
00:23:18,780 --> 00:23:19,863
I'll make sure to do that.

479
00:23:19,863 --> 00:23:21,160
Yeah.

480
00:23:21,160 --> 00:23:21,660
All right.

481
00:23:21,660 --> 00:23:23,520
So let me go ahead and
type that in the chat,

482
00:23:23,520 --> 00:23:26,645
but once we do that I'll send you all
to breakout rooms and come we'll come

483
00:23:26,645 --> 00:23:28,230
back in maybe 5 or 10 minutes or so.

484
00:23:28,230 --> 00:23:30,600
AUDIENCE: Can I ask you
a really quick question?

485
00:23:30,600 --> 00:23:35,155
Because I know for the lab, we had a
folder that we unzipped to invest code,

486
00:23:35,155 --> 00:23:37,030
is there something like
that for this section

487
00:23:37,030 --> 00:23:39,123
or should we just create our own file?

488
00:23:39,123 --> 00:23:40,290
CARTER ZENKE: Good question.

489
00:23:40,290 --> 00:23:42,720
Yeah, so normally for
a problem that you're

490
00:23:42,720 --> 00:23:46,890
working on in a problem set or a lab,
you might download a file, unzip it.

491
00:23:46,890 --> 00:23:48,633
Here, we're just making our own file.

492
00:23:48,633 --> 00:23:50,550
So if you want to, you
can go to your terminal

493
00:23:50,550 --> 00:23:55,300
down below, just type "code array.c"
and that should make you this new file.

494
00:23:55,300 --> 00:23:57,298
You can type in your code as we go.

495
00:23:57,298 --> 00:23:57,840
AUDIENCE: OK.

496
00:23:57,840 --> 00:23:58,470
Thank you.

497
00:23:58,470 --> 00:24:00,760
CARTER ZENKE: Yeah, yeah.

498
00:24:00,760 --> 00:24:02,110
So let me type this in the chat.

499
00:24:02,110 --> 00:24:09,980
So we'll create a program that
prompts the user for a size.

500
00:24:09,980 --> 00:24:13,490
And then we're going to
create an array of that size

501
00:24:13,490 --> 00:24:17,880
where each element is 2
times the previous one.

502
00:24:17,880 --> 00:24:20,830
And you can start the array at 1.

503
00:24:20,830 --> 00:24:26,110
And your goal is to ultimately print
the array of integer by integer.

504
00:24:26,110 --> 00:24:29,850


505
00:24:29,850 --> 00:24:31,230
So I hope that's helpful.

506
00:24:31,230 --> 00:24:33,730
I'll send you all into breakout
rooms in just a second here.

507
00:24:33,730 --> 00:24:38,070
We'll come back in let's
say, about five minutes.

508
00:24:38,070 --> 00:24:41,030


509
00:24:41,030 --> 00:24:42,278
Welcome back, everyone.

510
00:24:42,278 --> 00:24:44,570
I hope you got the to make
at least some progress here,

511
00:24:44,570 --> 00:24:46,970
but no worries if you didn't
get all the way there.

512
00:24:46,970 --> 00:24:49,380
What we'll do now is work on
this together a little bit.

513
00:24:49,380 --> 00:24:52,640
So here I have-- go
back to my view here--

514
00:24:52,640 --> 00:24:54,500
where we left off in our program.

515
00:24:54,500 --> 00:24:57,980
And again, the goal was to make
this array that every element was

516
00:24:57,980 --> 00:24:59,840
2 times the previous one.

517
00:24:59,840 --> 00:25:03,630
And it had the length of whatever
the user gave us in this case.

518
00:25:03,630 --> 00:25:06,960
So going back to some of the slides
that we just talked about earlier,

519
00:25:06,960 --> 00:25:12,470
how would we even declare or make
space for this array in our program?

520
00:25:12,470 --> 00:25:16,100
We want to have an array
that stores integers

521
00:25:16,100 --> 00:25:18,080
of a certain size and a certain name.

522
00:25:18,080 --> 00:25:20,720
And maybe could I have
Alena, if you don't mind,

523
00:25:20,720 --> 00:25:24,560
you want propose our array name
and length and what it stores?

524
00:25:24,560 --> 00:25:27,160


525
00:25:27,160 --> 00:25:34,393
AUDIENCE: So for the type, it
would just be "int" I think.

526
00:25:34,393 --> 00:25:35,560
CARTER ZENKE: Yeah, exactly.

527
00:25:35,560 --> 00:25:37,970
Storing integers.

528
00:25:37,970 --> 00:25:43,338
AUDIENCE: As for the size, I think the
size would need to be the user input.

529
00:25:43,338 --> 00:25:44,630
CARTER ZENKE: Yeah, definitely.

530
00:25:44,630 --> 00:25:47,128
So it would be the variable length here.

531
00:25:47,128 --> 00:25:49,920
And before we can give it a size
though, we have to give it a name.

532
00:25:49,920 --> 00:25:53,542
So you propose a name for us?

533
00:25:53,542 --> 00:25:55,750
AUDIENCE: I don't really
know what you would name it.

534
00:25:55,750 --> 00:25:58,220
But--

535
00:25:58,220 --> 00:26:00,280
CARTER ZENKE: Yeah, I
mean, it could be anything.

536
00:26:00,280 --> 00:26:02,020
We could call it--

537
00:26:02,020 --> 00:26:05,920
I would call it-- well, for
fun, we call it "twice",

538
00:26:05,920 --> 00:26:07,995
like twice the previous number.

539
00:26:07,995 --> 00:26:10,120
But you could also call it
array, you could call it

540
00:26:10,120 --> 00:26:11,950
whatever you want to call it.

541
00:26:11,950 --> 00:26:16,450
Here we'll say it has a certain
length and that length is literally

542
00:26:16,450 --> 00:26:17,600
this variable length here.

543
00:26:17,600 --> 00:26:21,440
So whatever we type in, that
will be the length of our array.

544
00:26:21,440 --> 00:26:25,870
Now if we wanted to go through
every element in the array,

545
00:26:25,870 --> 00:26:28,350
what loop might we use here?

546
00:26:28,350 --> 00:26:30,100
We want to go through
every element and we

547
00:26:30,100 --> 00:26:35,600
want to make sure that we set each of
those elements equal to some number.

548
00:26:35,600 --> 00:26:37,040
So what kind of loop could we use?

549
00:26:37,040 --> 00:26:39,998
Could I ask maybe Bianca if you might
have some thoughts here or ideas?

550
00:26:39,998 --> 00:26:49,060


551
00:26:49,060 --> 00:26:55,960
AUDIENCE: I want to say a for loop,
but or maybe another dua loop, unsure.

552
00:26:55,960 --> 00:26:59,860
CARTER ZENKE: Yeah, so for
loop is the right intuition.

553
00:26:59,860 --> 00:27:06,070
And why is because if we know how
many times we want to do something,

554
00:27:06,070 --> 00:27:08,440
we know we want to go through
every element of the array

555
00:27:08,440 --> 00:27:12,040
and it's like a fixed size, a for
loop is great because a for loop

556
00:27:12,040 --> 00:27:14,630
can do something a
certain number of times.

557
00:27:14,630 --> 00:27:19,960
So here, let's say I want to
loop from maybe I equals 0,

558
00:27:19,960 --> 00:27:23,110
all the way on up to
I is less than length.

559
00:27:23,110 --> 00:27:26,600
And increase I every time I go through.

560
00:27:26,600 --> 00:27:29,580
And so here's what that looks like here.

561
00:27:29,580 --> 00:27:35,900
And the goal here is, maybe we're
accessing every element of twice.

562
00:27:35,900 --> 00:27:41,000
By going from I is 0, all the way
up to I is not length, but one less

563
00:27:41,000 --> 00:27:42,170
than length.

564
00:27:42,170 --> 00:27:45,470
So it goes to every
element inside of "twice".

565
00:27:45,470 --> 00:27:49,130
But what should every
element inside of "twice" be?

566
00:27:49,130 --> 00:27:52,310
How do we complete this statement here?

567
00:27:52,310 --> 00:27:56,060
It should get a value, but
what value should it get?

568
00:27:56,060 --> 00:27:59,262


569
00:27:59,262 --> 00:28:01,470
Could I ask maybe McKenna
if you have any ideas here?

570
00:28:01,470 --> 00:28:08,208


571
00:28:08,208 --> 00:28:10,750
AUDIENCE: Sorry, could you repeat
the question one more time?

572
00:28:10,750 --> 00:28:11,792
CARTER ZENKE: Yeah, yeah.

573
00:28:11,792 --> 00:28:15,180
So we're just trying to figure
out what number should we

574
00:28:15,180 --> 00:28:19,630
put into each element of
this array called "twice"?

575
00:28:19,630 --> 00:28:22,770
We know that we want it to be two times
the previous number, but how would

576
00:28:22,770 --> 00:28:25,935
we actually put that in code
if you have any ideas here?

577
00:28:25,935 --> 00:28:28,450


578
00:28:28,450 --> 00:28:30,470
AUDIENCE: Two times i minus 1.

579
00:28:30,470 --> 00:28:31,720
CARTER ZENKE: Yeah, nice idea.

580
00:28:31,720 --> 00:28:37,450
We could say two times twice I minus 1.

581
00:28:37,450 --> 00:28:40,840
And this is going to do is
say, OK, let's make sure

582
00:28:40,840 --> 00:28:44,530
that the current space we're
looking at inside of "twice"

583
00:28:44,530 --> 00:28:49,400
is going to be two times the
previous value that's in twice here.

584
00:28:49,400 --> 00:28:55,430
So for example, if I is 1, then
we'll look back at 0, index 0 here.

585
00:28:55,430 --> 00:29:02,030
Multiply that by 2 and make that
the value of "twice" at the index 1.

586
00:29:02,030 --> 00:29:06,117
So let's go ahead and try running
this if I type "make array".

587
00:29:06,117 --> 00:29:08,450
Let's actually try printing
out this value as we go too.

588
00:29:08,450 --> 00:29:11,030
So I'll say, not only do we want to
set the value, I want to print it out

589
00:29:11,030 --> 00:29:11,640
as we go.

590
00:29:11,640 --> 00:29:17,570
So I'll say %i and then twice[i].

591
00:29:17,570 --> 00:29:23,480
I'll then recompile my program and
I'll do a ./array, maybe a size 5.

592
00:29:23,480 --> 00:29:27,590
But I get just 0s.

593
00:29:27,590 --> 00:29:29,760
Any ideas about this bug in our program?

594
00:29:29,760 --> 00:29:30,260
Yeah, Dewey?

595
00:29:30,260 --> 00:29:34,675


596
00:29:34,675 --> 00:29:36,550
AUDIENCE: Forgive me,
sorry, I had to unmute.

597
00:29:36,550 --> 00:29:42,200
So essentially, we need to set a value
for the first element in our array.

598
00:29:42,200 --> 00:29:45,160
Otherwise, it's just going to
take 0 and then just multiply it

599
00:29:45,160 --> 00:29:47,417
by 2, which is obviously 0.

600
00:29:47,417 --> 00:29:48,250
CARTER ZENKE: Right.

601
00:29:48,250 --> 00:29:50,920
Yeah, so we need to set
a first element here.

602
00:29:50,920 --> 00:29:56,710
And more specifically, what's
happening is let's say i is o, well OK,

603
00:29:56,710 --> 00:30:02,290
twice[0] should be 2 times twice[-1].

604
00:30:02,290 --> 00:30:06,322
And so negative 1 will look one
space in memory before our array.

605
00:30:06,322 --> 00:30:07,780
And really, who knows what's there.

606
00:30:07,780 --> 00:30:09,697
It could be 0, it could
be some random number.

607
00:30:09,697 --> 00:30:13,400
If I were to try re-running this
program, I get a different answer.

608
00:30:13,400 --> 00:30:15,650
Still 0, we run this again.

609
00:30:15,650 --> 00:30:18,710
Still 0, but we might get some
random number there eventually

610
00:30:18,710 --> 00:30:23,220
because we're not really sure what's
one space memory before our array.

611
00:30:23,220 --> 00:30:28,820
So to Dewey's point, let's
actually first set twice[0] to 1.

612
00:30:28,820 --> 00:30:31,160
That first element of
twice, set it to 1.

613
00:30:31,160 --> 00:30:33,650
Then we'll go ahead
and start from i equals

614
00:30:33,650 --> 00:30:38,190
1 and look one behind us, multiplying
that by 2 as we go through.

615
00:30:38,190 --> 00:30:40,550
So I'll do "make array".

616
00:30:40,550 --> 00:30:42,972
I'll do a ./array of size 5.

617
00:30:42,972 --> 00:30:44,930
And now I get something
that looks pretty good,

618
00:30:44,930 --> 00:30:47,660
but I don't think I have
the full array here.

619
00:30:47,660 --> 00:30:48,995
What else do I still need to do?

620
00:30:48,995 --> 00:30:51,944


621
00:30:51,944 --> 00:30:55,420
Let me go back my terminal
I only see 2, 4, 8, 16.

622
00:30:55,420 --> 00:31:04,007


623
00:31:04,007 --> 00:31:06,590
Any thoughts, Dewey, if you want
to finish the debugging here?

624
00:31:06,590 --> 00:31:10,745


625
00:31:10,745 --> 00:31:11,870
AUDIENCE: Give me a second.

626
00:31:11,870 --> 00:31:15,525
Let me just pull up--

627
00:31:15,525 --> 00:31:16,510
OK.

628
00:31:16,510 --> 00:31:24,920
So we're not seeing the
entirety of the array.

629
00:31:24,920 --> 00:31:31,210
So we're only seeing up until the
last four, even though we want five.

630
00:31:31,210 --> 00:31:34,150
So it's not showing the
zeroth element, which is 1.

631
00:31:34,150 --> 00:31:38,927
So we should probably should
printf twicE[0], for instance.

632
00:31:38,927 --> 00:31:41,510
CARTER ZENKE: Yeah, so we've got
to print it out here as well.

633
00:31:41,510 --> 00:31:45,670
So I'll say print out
whatever's in twice[0],

634
00:31:45,670 --> 00:31:47,680
right after we set its value there.

635
00:31:47,680 --> 00:31:50,680
So basically, we're going to fill in
the very first element of our array

636
00:31:50,680 --> 00:31:52,180
on lines 15 and 16.

637
00:31:52,180 --> 00:31:56,420
Then we're going to fill in the rest
of our array on lines 18 through 22.

638
00:31:56,420 --> 00:32:02,120
So now if I compile this,
"make array", I'll run array.

639
00:32:02,120 --> 00:32:05,600
And now I'll see every
element inside of that array.

640
00:32:05,600 --> 00:32:09,520
So what questions are there on
this program, or arrays in general?

641
00:32:09,520 --> 00:32:12,480
Any lingering thoughts or questions?

642
00:32:12,480 --> 00:32:17,460
AUDIENCE: Could you go back to
where you had after "int twice",

643
00:32:17,460 --> 00:32:19,310
the line of code you have after that.

644
00:32:19,310 --> 00:32:22,620
And explain that, if you don't mind?

645
00:32:22,620 --> 00:32:23,910
CARTER ZENKE: Yeah, totally.

646
00:32:23,910 --> 00:32:26,993
So here, let me actually comment the
code, just to make it little clearer.

647
00:32:26,993 --> 00:32:32,252
So here, we're going to get
the length from the user.

648
00:32:32,252 --> 00:32:33,960
Now once we have that
length, we're going

649
00:32:33,960 --> 00:32:38,735
to declare our array, which
means make some space for it

650
00:32:38,735 --> 00:32:40,530
in our computer's memory.

651
00:32:40,530 --> 00:32:44,860
And here what we're doing is
going to set the first value.

652
00:32:44,860 --> 00:32:47,010
So our array should start at 1.

653
00:32:47,010 --> 00:32:49,680
And so we'll take the
very first element inside

654
00:32:49,680 --> 00:32:51,870
of twice using that 0 index here.

655
00:32:51,870 --> 00:32:53,830
Remember, we start from 0 and go on up.

656
00:32:53,830 --> 00:32:56,130
We'll say that gets the value 1.

657
00:32:56,130 --> 00:32:59,280
I will then print out that value.

658
00:32:59,280 --> 00:33:01,440
And then we'll look at
the rest of our array.

659
00:33:01,440 --> 00:33:05,580
We'll start at i equals 1
instead of i equals 0 here.

660
00:33:05,580 --> 00:33:08,950
Move on up to the length,
increasing i as we go.

661
00:33:08,950 --> 00:33:16,990
And as we do it, let's go ahead and make
the current element twice the previous.

662
00:33:16,990 --> 00:33:19,285
And then we'll print
out the current element.

663
00:33:19,285 --> 00:33:21,800


664
00:33:21,800 --> 00:33:24,530
Does that make sense?

665
00:33:24,530 --> 00:33:26,270
Nice.

666
00:33:26,270 --> 00:33:27,605
Other questions on this one?

667
00:33:27,605 --> 00:33:35,340


668
00:33:35,340 --> 00:33:36,360
All right.

669
00:33:36,360 --> 00:33:38,490
So let's keep moving in that case.

670
00:33:38,490 --> 00:33:44,400
And our next topic following through
on arrays is this idea of a string.

671
00:33:44,400 --> 00:33:47,300
And what are strings really?

672
00:33:47,300 --> 00:33:49,400
We saw this in lecture a little bit.

673
00:33:49,400 --> 00:33:56,570
Strings are these collections of
characters, like a name, like Carter,

674
00:33:56,570 --> 00:33:59,810
or maybe a location, like Harvard.

675
00:33:59,810 --> 00:34:04,490
But what data structure are they really?

676
00:34:04,490 --> 00:34:10,360


677
00:34:10,360 --> 00:34:13,900
Maybe could I ask Elena if you
have any thoughts or guesses here?

678
00:34:13,900 --> 00:34:18,000


679
00:34:18,000 --> 00:34:21,030
AUDIENCE: From what I understand,
I just thought of strings

680
00:34:21,030 --> 00:34:26,153
as strings of characters
instead of just one character.

681
00:34:26,153 --> 00:34:27,320
CARTER ZENKE: Yeah, totally.

682
00:34:27,320 --> 00:34:29,449
So a string is like a
string of characters.

683
00:34:29,449 --> 00:34:34,469
We've taken some individual characters
and strung them together, so to speak.

684
00:34:34,469 --> 00:34:39,260
And this name comes from the fact
that we have some characters now all

685
00:34:39,260 --> 00:34:40,320
grouped together.

686
00:34:40,320 --> 00:34:43,280
And so similarly, how
we had these hours that

687
00:34:43,280 --> 00:34:46,070
were previously individual
variables, but now I

688
00:34:46,070 --> 00:34:49,221
put them in this array called "hours",
we can do the same for strings.

689
00:34:49,221 --> 00:34:50,929
We're taking these
individual characters,

690
00:34:50,929 --> 00:34:53,610
putting them together into
this one, big array here.

691
00:34:53,610 --> 00:34:57,890
So if I take a look at this
string, this string is "Emma".

692
00:34:57,890 --> 00:34:59,930
And if we take a look
at the entire string,

693
00:34:59,930 --> 00:35:02,960
we'll see it's basically
the same idea as an array.

694
00:35:02,960 --> 00:35:05,630
We have this name for the array.

695
00:35:05,630 --> 00:35:10,820
We have some elements inside each
individual block of that array.

696
00:35:10,820 --> 00:35:12,888
And we have that same
syntax to get access

697
00:35:12,888 --> 00:35:14,430
to individual elements of that array.

698
00:35:14,430 --> 00:35:17,720
So name[0], name[1], and so on.

699
00:35:17,720 --> 00:35:20,810
But what's kind of special
about this string here?

700
00:35:20,810 --> 00:35:23,270
If we take a look at that
last element, does anyone

701
00:35:23,270 --> 00:35:26,270
remember what that last
element was called?

702
00:35:26,270 --> 00:35:31,260
Just to show you again,
looks like a "slash 0".

703
00:35:31,260 --> 00:35:32,135
What was that called?

704
00:35:32,135 --> 00:35:35,640


705
00:35:35,640 --> 00:35:37,710
AUDIENCE: Wasn't it the null character?

706
00:35:37,710 --> 00:35:38,190
CARTER ZENKE: Yeah, right.

707
00:35:38,190 --> 00:35:39,300
It was the null character.

708
00:35:39,300 --> 00:35:40,883
And you remember what its purpose was?

709
00:35:40,883 --> 00:35:44,830


710
00:35:44,830 --> 00:35:46,690
Maybe go ahead, Dewey, yeah.

711
00:35:46,690 --> 00:35:48,398
AUDIENCE: It marks
the end of the string.

712
00:35:48,398 --> 00:35:50,523
CARTER ZENKE: Yeah, It
marks the end of the string.

713
00:35:50,523 --> 00:35:52,750
So otherwise, we wouldn't
really quite know where

714
00:35:52,750 --> 00:35:55,100
to stop if we were looking at a string.

715
00:35:55,100 --> 00:35:58,930
We have to have some way of knowing,
OK, this is the end of our string now.

716
00:35:58,930 --> 00:36:01,810
But here, we have this null
character tell us, OK, that

717
00:36:01,810 --> 00:36:04,900
is going to be the end of our string.

718
00:36:04,900 --> 00:36:09,520
If we want to make this
same string, we could do so

719
00:36:09,520 --> 00:36:11,300
by making an array of characters.

720
00:36:11,300 --> 00:36:16,120
So here, we have up above,
this array called name.

721
00:36:16,120 --> 00:36:18,340
And it's full of characters.

722
00:36:18,340 --> 00:36:23,200
And we've given it some elements here,
E, m, m, a, and that null character.

723
00:36:23,200 --> 00:36:27,490
So we've composed this string
ourselves from individual characters.

724
00:36:27,490 --> 00:36:33,520
And this syntax here, string name gets
the value "Emma" is kind of some sugar

725
00:36:33,520 --> 00:36:36,340
that we've given you to make
it easier to declare an array.

726
00:36:36,340 --> 00:36:40,133
This is based in the CS50
library, but on your own,

727
00:36:40,133 --> 00:36:42,800
if you were off into the world
and programming C more generally,

728
00:36:42,800 --> 00:36:46,732
you might make strings a
little bit more like this,

729
00:36:46,732 --> 00:36:49,190
or you might use some libraries
to simplify things for you,

730
00:36:49,190 --> 00:36:52,000
but basically, under the hood,
this array is this array--

731
00:36:52,000 --> 00:36:55,510
or the string is this
array of characters.

732
00:36:55,510 --> 00:36:58,930
And notice similarities here
between this array called "name",

733
00:36:58,930 --> 00:37:00,490
and this array called "hours".

734
00:37:00,490 --> 00:37:02,290
It's much the same
thing, just here we're

735
00:37:02,290 --> 00:37:05,547
storing integers versus
storing characters.

736
00:37:05,547 --> 00:37:07,630
That's handy because we
can do all the same things

737
00:37:07,630 --> 00:37:09,610
we could do with arrays earlier.

738
00:37:09,610 --> 00:37:12,940
We can have name[0] to
get that first character,

739
00:37:12,940 --> 00:37:17,300
name[1] to get that second
character, and so on.

740
00:37:17,300 --> 00:37:19,810
And so just curious here,
any questions on strings

741
00:37:19,810 --> 00:37:22,855
or how they're similar to arrays
or the syntax that we've seen here?

742
00:37:22,855 --> 00:37:28,820


743
00:37:28,820 --> 00:37:29,832
All right.

744
00:37:29,832 --> 00:37:31,540
AUDIENCE: Sorry, just
one quick question.

745
00:37:31,540 --> 00:37:35,390
You can't circle through a string in
the same way you can with an array?

746
00:37:35,390 --> 00:37:38,120
Like in a string, you couldn't
say the first character

747
00:37:38,120 --> 00:37:40,715
with square brackets for stricter--

748
00:37:40,715 --> 00:37:42,890
square bracket 0 and then 1.

749
00:37:42,890 --> 00:37:45,520
That's unique to arrays?

750
00:37:45,520 --> 00:37:47,770
CARTER ZENKE: It's unique to arrays.

751
00:37:47,770 --> 00:37:51,550
Arrays are the only data structure
that have that bracket notation,

752
00:37:51,550 --> 00:37:54,560
but the nice thing about a string
is a string just is an array.

753
00:37:54,560 --> 00:37:56,750
So you can get that same functionality.

754
00:37:56,750 --> 00:38:02,110
So here, even if we didn't do this, we
didn't spell out the array like this,

755
00:38:02,110 --> 00:38:07,150
we just did string name gets the value
"Emma", we could still do this syntax.

756
00:38:07,150 --> 00:38:09,910
Name[0] gets that capital
E at the beginning,

757
00:38:09,910 --> 00:38:14,180
name[1] gets that second
character, that m there and so on.

758
00:38:14,180 --> 00:38:15,950
Does that make sense?

759
00:38:15,950 --> 00:38:18,010
Nice.

760
00:38:18,010 --> 00:38:19,975
Other questions too on these strings?

761
00:38:19,975 --> 00:38:28,410


762
00:38:28,410 --> 00:38:29,370
OK.

763
00:38:29,370 --> 00:38:32,580
So one of the interesting
things about these characters

764
00:38:32,580 --> 00:38:37,860
is that they're represented ultimately,
by binary, everything in the end is.

765
00:38:37,860 --> 00:38:42,120
But in C, we have this
dual representation

766
00:38:42,120 --> 00:38:47,970
of characters, where this capital
A is represented by the number, 65.

767
00:38:47,970 --> 00:38:50,730
Lowercase a is represented
by the number, 97.

768
00:38:50,730 --> 00:38:54,360
And somebody came up with this, The
American Standard Code for Information

769
00:38:54,360 --> 00:38:55,500
Interchange, I believe.

770
00:38:55,500 --> 00:38:58,890
I'm not misremembering there, or ASCI.

771
00:38:58,890 --> 00:39:03,240
And so ASCI defines these
relationships between these characters

772
00:39:03,240 --> 00:39:04,590
and these numbers.

773
00:39:04,590 --> 00:39:08,650
And the interesting thing is, if I
were to go to my code space here,

774
00:39:08,650 --> 00:39:13,620
let's say I wanted to make
a file called "string.c",

775
00:39:13,620 --> 00:39:19,110
I could include all the
files I need, like this.

776
00:39:19,110 --> 00:39:23,500
I could make my main
function, and let's say

777
00:39:23,500 --> 00:39:28,190
I did have this string called
Emma, well, what I could do

778
00:39:28,190 --> 00:39:31,230
is I could print out every
letter, kind of like this.

779
00:39:31,230 --> 00:39:34,640
I could say for int i is
zero, i is less than--

780
00:39:34,640 --> 00:39:35,540
oh.

781
00:39:35,540 --> 00:39:39,380
Well, how long is Emma?

782
00:39:39,380 --> 00:39:42,410
How many characters should I go?

783
00:39:42,410 --> 00:39:44,813
We don't-- I mean, you could
look at it and say it's for.

784
00:39:44,813 --> 00:39:46,230
But there's a better way to do it.

785
00:39:46,230 --> 00:39:48,380
And we saw a function in lecture.

786
00:39:48,380 --> 00:39:49,470
What could we do?

787
00:39:49,470 --> 00:39:49,970
Yeah, Dewey?

788
00:39:49,970 --> 00:39:52,790


789
00:39:52,790 --> 00:39:54,770
AUDIENCE: Str len?

790
00:39:54,770 --> 00:39:56,870
CARTER ZENKE: Yeah, we need str len.

791
00:39:56,870 --> 00:40:01,670
str len is this function
in the string.h library.

792
00:40:01,670 --> 00:40:05,030
We might say strlen,
kind of for short here.

793
00:40:05,030 --> 00:40:08,000
And we want to get the
length of our strings.

794
00:40:08,000 --> 00:40:15,305
We could say this new variable, called
length, gets the length of name.

795
00:40:15,305 --> 00:40:16,930
And now we can kind of finish for loop.

796
00:40:16,930 --> 00:40:20,770
We could say, i is less than the
length of that string, i plus,

797
00:40:20,770 --> 00:40:23,090
plus, it's increasing by 1 as we go.

798
00:40:23,090 --> 00:40:32,190
And now we'll say, OK, print out
for me whatever character is inside

799
00:40:32,190 --> 00:40:34,050
of name[i].

800
00:40:34,050 --> 00:40:36,810
And so however, to make this,
compile it to machine code.

801
00:40:36,810 --> 00:40:45,170
I could run .string and I see E, M, M,
A. All of these individual characters.

802
00:40:45,170 --> 00:40:47,720
But what I could do
too is I could say, I

803
00:40:47,720 --> 00:40:49,610
want the integer representation of this.

804
00:40:49,610 --> 00:40:51,620
I want to print this as an integer.

805
00:40:51,620 --> 00:40:53,810
I could recompile this.

806
00:40:53,810 --> 00:40:58,990
And I'm going to actually add this new
line at the very end of my program now.

807
00:40:58,990 --> 00:41:02,080
I could say, "make string"
and then "./string".

808
00:41:02,080 --> 00:41:08,470
And now I don't get E, M, M,
A, I get 69, 109, 109, 97.

809
00:41:08,470 --> 00:41:11,050
So whenever you're
working with characters,

810
00:41:11,050 --> 00:41:14,690
you can also treat them as numbers.

811
00:41:14,690 --> 00:41:17,870
And we can do this
interchangeably as we go through.

812
00:41:17,870 --> 00:41:20,660
I could say is a certain number--

813
00:41:20,660 --> 00:41:24,290
or is a certain character more than
or less than some number, or things

814
00:41:24,290 --> 00:41:26,010
like that.

815
00:41:26,010 --> 00:41:28,670
It'll be useful for us as we
work on this next exercise

816
00:41:28,670 --> 00:41:33,080
here where we're going to try to
figure out if a string characters are

817
00:41:33,080 --> 00:41:35,100
in alphabetical order.

818
00:41:35,100 --> 00:41:37,745
So what do we notice here if
we go back to this ASCI chart?

819
00:41:37,745 --> 00:41:40,330


820
00:41:40,330 --> 00:41:44,790
We look down at this lowercase half.

821
00:41:44,790 --> 00:41:47,910
What do you notice as the numbers
get further in the alphabet?

822
00:41:47,910 --> 00:41:53,010


823
00:41:53,010 --> 00:41:54,960
What happens to the numbers?

824
00:41:54,960 --> 00:41:56,880
Can I ask maybe Bianca,
if you don't mind?

825
00:41:56,880 --> 00:42:01,470
How are these numbers changing
as we go further in the alphabet?

826
00:42:01,470 --> 00:42:03,300
AUDIENCE: They increased in value.

827
00:42:03,300 --> 00:42:06,180
CARTER ZENKE: Yeah, they
keep increasing in value.

828
00:42:06,180 --> 00:42:11,640
So to figure out if a strange character
is in alphabetical order, what

829
00:42:11,640 --> 00:42:15,930
we could do is just check to
see is each character greater

830
00:42:15,930 --> 00:42:18,532
than the one behind it?

831
00:42:18,532 --> 00:42:20,740
So let's go ahead and get
start on this one together.

832
00:42:20,740 --> 00:42:24,927
We could maybe go to our terminal
here and code up alpha.c.

833
00:42:24,927 --> 00:42:27,510
And this would be our new file,
not downloading anything, just

834
00:42:27,510 --> 00:42:29,720
making a new file here.

835
00:42:29,720 --> 00:42:32,830
And we could say I want to
include the CS50 library.

836
00:42:32,830 --> 00:42:36,490
I want to include standard
IO.h to print things out

837
00:42:36,490 --> 00:42:38,650
and I want to have this
main function still.

838
00:42:38,650 --> 00:42:40,690
This main part of my program.

839
00:42:40,690 --> 00:42:44,650
And now what I could
do is I could say, I

840
00:42:44,650 --> 00:42:47,630
want to get some string from the user.

841
00:42:47,630 --> 00:42:52,430
So I could say, string
word is going to get--

842
00:42:52,430 --> 00:42:52,930
what?

843
00:42:52,930 --> 00:42:54,930
What kind of function can
we use to get a string

844
00:42:54,930 --> 00:42:58,860
from the user from the CS50 library?

845
00:42:58,860 --> 00:43:01,050
Maybe Elena, do you
have any thoughts here?

846
00:43:01,050 --> 00:43:04,070


847
00:43:04,070 --> 00:43:05,363
AUDIENCE: So I'm not sure.

848
00:43:05,363 --> 00:43:06,280
CARTER ZENKE: It's OK.

849
00:43:06,280 --> 00:43:08,280
We're trying to get a
string from the user here.

850
00:43:08,280 --> 00:43:14,185
So how could we-- what kind of functions
in CS50 library might be useful for us?

851
00:43:14,185 --> 00:43:15,160
AUDIENCE: Get string.

852
00:43:15,160 --> 00:43:15,970
CARTER ZENKE: Yeah, get string.

853
00:43:15,970 --> 00:43:17,220
So we could say, "get string".

854
00:43:17,220 --> 00:43:20,720
And maybe in this case, enter a word.

855
00:43:20,720 --> 00:43:24,660
And the rest of our program
I might leave up to you.

856
00:43:24,660 --> 00:43:27,470
But again, the goal is to
check if a lowercase strings

857
00:43:27,470 --> 00:43:29,490
characters are in alphabetical order.

858
00:43:29,490 --> 00:43:30,710
And if they are, print "yes".

859
00:43:30,710 --> 00:43:32,568
If they aren't, we'll print "no".

860
00:43:32,568 --> 00:43:34,610
And you might want to have
some kind of loop that

861
00:43:34,610 --> 00:43:38,180
goes through a every character and
does that check for you, checking

862
00:43:38,180 --> 00:43:42,650
to see if each character is more
than or less than the one behind it

863
00:43:42,650 --> 00:43:44,900
and making a decision based
off of that to figure out

864
00:43:44,900 --> 00:43:47,380
if it's in alphabetical order or not.

865
00:43:47,380 --> 00:43:50,630
So I'll go ahead and paste this one in
the chat for you all, but any questions

866
00:43:50,630 --> 00:43:51,530
before we begin here?

867
00:43:51,530 --> 00:44:00,740


868
00:44:00,740 --> 00:44:03,875
Not seeing any I'm just
finishing typing in the chat.

869
00:44:03,875 --> 00:44:12,570


870
00:44:12,570 --> 00:44:15,740
And you might find ASCIchart.com
useful to go ahead and take

871
00:44:15,740 --> 00:44:21,360
a look at the representation of these
characters as numbers in this case.

872
00:44:21,360 --> 00:44:25,550
So we'll go back into some breakout
rooms for, let's say, five minutes.

873
00:44:25,550 --> 00:44:28,400
We'll come back afterwards to do
this together and then talk more

874
00:44:28,400 --> 00:44:30,450
about command line arguments and yeah.

875
00:44:30,450 --> 00:44:36,330
So let me go ahead and open these
up and I'll see you in a few.

876
00:44:36,330 --> 00:44:36,830
All right.

877
00:44:36,830 --> 00:44:38,097
Welcome back, everyone.

878
00:44:38,097 --> 00:44:40,430
Again, I hope you made at
least a little bit of progress

879
00:44:40,430 --> 00:44:43,200
or you learn something while
you were working on this.

880
00:44:43,200 --> 00:44:45,480
It's a little bit more
on the advanced side.

881
00:44:45,480 --> 00:44:47,300
So what we do is take
a look at a solution

882
00:44:47,300 --> 00:44:52,440
together, walk through what it does and
see what questions come up as we do so.

883
00:44:52,440 --> 00:44:55,130
So here is one way of
approaching this problem.

884
00:44:55,130 --> 00:44:57,870
I can Zoom in a little bit here.

885
00:44:57,870 --> 00:45:02,660
And what we'll do is we'll first get
our string from the user on this line 7.

886
00:45:02,660 --> 00:45:06,950
And then we'll go ahead and
figure out how long that word is.

887
00:45:06,950 --> 00:45:11,630
Now what we'll do is we'll go
through every character front to back

888
00:45:11,630 --> 00:45:16,670
and say, OK, let's check if the
character is not alphabetical.

889
00:45:16,670 --> 00:45:19,280
Often in computer science, it's
easier to check for something

890
00:45:19,280 --> 00:45:23,580
that if it's not true, then it is to
check for something if it is true.

891
00:45:23,580 --> 00:45:26,690
So here we're going to say, I want
to see if it's not alphabetical.

892
00:45:26,690 --> 00:45:29,000
And if it is, I want
to go ahead and print

893
00:45:29,000 --> 00:45:34,250
"no" it's not alphabetical and return
0, meaning I'm going to exit my program.

894
00:45:34,250 --> 00:45:36,510
Nothing else will happen here.

895
00:45:36,510 --> 00:45:40,410
But assuming I actually get through
this loop, all the way through,

896
00:45:40,410 --> 00:45:43,370
I'll go ahead and print "yes".

897
00:45:43,370 --> 00:45:47,720
The key intuition here is that we
know if something's not alphabetical

898
00:45:47,720 --> 00:45:51,260
when the current character
has a value that's greater

899
00:45:51,260 --> 00:45:54,750
than the character that's before it.

900
00:45:54,750 --> 00:46:00,380
So here, if I were, to example,
say look at-- actually, yeah,

901
00:46:00,380 --> 00:46:02,060
before the character that is--

902
00:46:02,060 --> 00:46:08,780
yeah, so here, I would look at
B and say, OK, B in this case

903
00:46:08,780 --> 00:46:12,620
is greater than A. If we look
at that chart from earlier,

904
00:46:12,620 --> 00:46:15,320
let me go back here.

905
00:46:15,320 --> 00:46:16,850
Open this up.

906
00:46:16,850 --> 00:46:21,720
We could see that B is a 98 and A is 97.

907
00:46:21,720 --> 00:46:26,900
So in this case, if we ever
find that this character here

908
00:46:26,900 --> 00:46:30,450
is greater than the
character ahead of it,

909
00:46:30,450 --> 00:46:33,890
we know that we've found a
non-alphabetical sequence.

910
00:46:33,890 --> 00:46:35,300
And we can go ahead and say "no".

911
00:46:35,300 --> 00:46:37,028
In this case.

912
00:46:37,028 --> 00:46:40,070
Assuming we get all the way through
though and we don't ever trigger this

913
00:46:40,070 --> 00:46:42,110
and we don't ever end
our program early, we

914
00:46:42,110 --> 00:46:45,350
could assume that everything must
be alphabetical unless "return 0"

915
00:46:45,350 --> 00:46:47,608
at the end.

916
00:46:47,608 --> 00:46:50,900
So questions on this or places you were
getting stuck as we were going through?

917
00:46:50,900 --> 00:46:52,370
Yeah, Dewey?

918
00:46:52,370 --> 00:46:55,415
AUDIENCE: You don't need the
return 0 at the end, right? like,

919
00:46:55,415 --> 00:46:57,140
after the "print yes".

920
00:46:57,140 --> 00:47:00,020
You need it for the "print no" I
think, but not the "print yes".

921
00:47:00,020 --> 00:47:02,360
CARTER ZENKE: Yeah, we
don't really need this here.

922
00:47:02,360 --> 00:47:06,650
Maybe it's good for completeness
sake to have some return value there.

923
00:47:06,650 --> 00:47:10,100
But C will automatically
return 0 as soon

924
00:47:10,100 --> 00:47:14,900
as you hit this bottom
semicolon of your main function.

925
00:47:14,900 --> 00:47:16,730
The return 0 here,
though, as you said, is

926
00:47:16,730 --> 00:47:18,680
necessary because it
ends our program early

927
00:47:18,680 --> 00:47:24,632
and keeps us from printing no, no, no,
no, no as we go through our program.

928
00:47:24,632 --> 00:47:25,840
AUDIENCE: Could you explain--

929
00:47:25,840 --> 00:47:26,940
CARTER ZENKE: Other questions?

930
00:47:26,940 --> 00:47:29,550
AUDIENCE: Could you explain one more
time how you need to do string length

931
00:47:29,550 --> 00:47:30,490
as the first--

932
00:47:30,490 --> 00:47:31,742
like at the top?

933
00:47:31,742 --> 00:47:32,700
CARTER ZENKE: Oh, yeah.

934
00:47:32,700 --> 00:47:34,982
Like up here?

935
00:47:34,982 --> 00:47:35,740
Yeah.

936
00:47:35,740 --> 00:47:38,440
So in general, when you
want to do something

937
00:47:38,440 --> 00:47:42,700
for every character in
a string, you generally

938
00:47:42,700 --> 00:47:44,530
want to have some form of strlen.

939
00:47:44,530 --> 00:47:50,720
And strlen is going to tell you how many
times you should loop in your for loop.

940
00:47:50,720 --> 00:47:54,970
So here, for example, if I wanted
to figure out how do I do something

941
00:47:54,970 --> 00:47:56,890
for every character in my array?

942
00:47:56,890 --> 00:47:59,770
Well, I have to know how
many times to loop and thus

943
00:47:59,770 --> 00:48:02,290
I have to know how long my string is.

944
00:48:02,290 --> 00:48:04,570
So I know I need strlen
to figure that out for me

945
00:48:04,570 --> 00:48:07,580
and I can use that variable
in my for loop later on.

946
00:48:07,580 --> 00:48:09,955
Does that make sense?

947
00:48:09,955 --> 00:48:11,760
Nice.

948
00:48:11,760 --> 00:48:13,350
OK, other questions here too?

949
00:48:13,350 --> 00:48:20,670


950
00:48:20,670 --> 00:48:22,540
All right.

951
00:48:22,540 --> 00:48:24,510
So not seeing any there.

952
00:48:24,510 --> 00:48:27,010
So let's go ahead and move on
to some command line arguments

953
00:48:27,010 --> 00:48:28,780
just to wrap up our section today.

954
00:48:28,780 --> 00:48:31,405
I know there was some excitement
around command line arguments.

955
00:48:31,405 --> 00:48:32,613
They're pretty cool actually.

956
00:48:32,613 --> 00:48:35,920
You could actually use them
to modify our program behavior

957
00:48:35,920 --> 00:48:38,050
as we type it in at the terminal.

958
00:48:38,050 --> 00:48:41,632
And so maybe you're used to using a
GUI or a graphical user interface,

959
00:48:41,632 --> 00:48:44,590
but you'll get used to, as you do
more programming, using this terminal

960
00:48:44,590 --> 00:48:45,090
interface.

961
00:48:45,090 --> 00:48:46,840
You can type in a
program's name and then

962
00:48:46,840 --> 00:48:49,390
go ahead and give it
some options to run with.

963
00:48:49,390 --> 00:48:52,720
And we saw Clang earlier, this
compiler for the C language.

964
00:48:52,720 --> 00:48:55,340
And Clang does take some
command line arguments.

965
00:48:55,340 --> 00:48:58,460
So we saw it could take this
argument called Mario.c.

966
00:48:58,460 --> 00:49:00,460
And this is a command
line argument because it's

967
00:49:00,460 --> 00:49:03,668
given to the program at the terminal,
it's not an option we give to a program

968
00:49:03,668 --> 00:49:07,630
as it's running, it's given
to our program before it runs.

969
00:49:07,630 --> 00:49:08,680
We could also give more.

970
00:49:08,680 --> 00:49:12,700
We could say the output of
this compiler should be Mario,

971
00:49:12,700 --> 00:49:14,470
this file called Mario.

972
00:49:14,470 --> 00:49:16,630
And even make itself takes
command line arguments,

973
00:49:16,630 --> 00:49:20,690
that Mario right there at the very end.

974
00:49:20,690 --> 00:49:24,370
And we could even have another program
called "initials", for example.

975
00:49:24,370 --> 00:49:25,810
Actually no, I think we--

976
00:49:25,810 --> 00:49:27,820
we'll get to initials
in just a minute, sorry.

977
00:49:27,820 --> 00:49:30,220
But the intuition behind
command line arguments

978
00:49:30,220 --> 00:49:34,250
comes from this idea of these functions
that take their own arguments.

979
00:49:34,250 --> 00:49:39,500
So in an earlier problem, you maybe
saw this calculate quarters function.

980
00:49:39,500 --> 00:49:41,680
And here, this calculate
quarters function

981
00:49:41,680 --> 00:49:44,980
takes this argument called "sense".

982
00:49:44,980 --> 00:49:48,790
And this program or this function
takes that input and then

983
00:49:48,790 --> 00:49:50,830
does something different
because it's given

984
00:49:50,830 --> 00:49:53,930
that input, this argument over here.

985
00:49:53,930 --> 00:49:58,030
Similarly in our programs,
we have this main function

986
00:49:58,030 --> 00:50:00,640
where this is the
function that gets called

987
00:50:00,640 --> 00:50:03,260
as we type the name of our
program in the terminal.

988
00:50:03,260 --> 00:50:06,250
So if I were to type
maybe ./mario, again,

989
00:50:06,250 --> 00:50:08,930
my main function is being called.

990
00:50:08,930 --> 00:50:12,730
Now Mario didn't take any command
line arguments and because of that,

991
00:50:12,730 --> 00:50:18,280
we typed "int main and void, where
void says no input to our program

992
00:50:18,280 --> 00:50:20,500
is given at the command line.

993
00:50:20,500 --> 00:50:23,710
We do return something from
this function, an integer,

994
00:50:23,710 --> 00:50:25,990
kind of like a status code
that we saw in lecture.

995
00:50:25,990 --> 00:50:30,730
But the input to this program
is void, is currently nothing.

996
00:50:30,730 --> 00:50:35,355
If we did though want to give our
program some input it could run with,

997
00:50:35,355 --> 00:50:37,480
typically, in our programs
we would write something

998
00:50:37,480 --> 00:50:41,440
like this, "int argc" and "string Argv".

999
00:50:41,440 --> 00:50:43,180
That's an array.

1000
00:50:43,180 --> 00:50:46,810
And the reason we do this, we often
want two pieces of information

1001
00:50:46,810 --> 00:50:47,980
as our program starts.

1002
00:50:47,980 --> 00:50:51,130
We want to know how many
arguments were given,

1003
00:50:51,130 --> 00:50:53,920
and that's argc for argument count.

1004
00:50:53,920 --> 00:50:57,130
Notice how it's an integer
called argc for argument count.

1005
00:50:57,130 --> 00:51:00,910
That's how many arguments you've
given at the command line.

1006
00:51:00,910 --> 00:51:03,850
And we're also given this
array of those arguments called

1007
00:51:03,850 --> 00:51:06,920
argv, which stands for argument vector.

1008
00:51:06,920 --> 00:51:10,150
And so argument vector,
argv is this array

1009
00:51:10,150 --> 00:51:13,810
of strings that have been given to
our program at the command line.

1010
00:51:13,810 --> 00:51:18,280
And we can use those in our
program to modify its behavior.

1011
00:51:18,280 --> 00:51:22,820
Now for example, if we were to go
in and make our own program here.

1012
00:51:22,820 --> 00:51:27,370
I could do maybe "code CLA"
for command line arguments.

1013
00:51:27,370 --> 00:51:29,260
And I could then do all the usual stuff.

1014
00:51:29,260 --> 00:51:32,050
I could include "stdio.h".

1015
00:51:32,050 --> 00:51:35,350
I could include maybe "CS50.h".

1016
00:51:35,350 --> 00:51:38,402
And I could do "int
main", but this time, I

1017
00:51:38,402 --> 00:51:39,860
want to take command line argument.

1018
00:51:39,860 --> 00:51:43,855
So I could say, "int argc, string argv".

1019
00:51:43,855 --> 00:51:47,910
And what this will do for me is allow me
to figure out what else was typed along

1020
00:51:47,910 --> 00:51:48,990
with my program?

1021
00:51:48,990 --> 00:51:50,900
And to do so, I might do the following.

1022
00:51:50,900 --> 00:51:54,220
I try to go through every
element of this argv array.

1023
00:51:54,220 --> 00:51:57,690
So I could say "for int i is zero".

1024
00:51:57,690 --> 00:52:00,960
I is less than argc, I plus, plus.

1025
00:52:00,960 --> 00:52:04,720
Let me loop through every
argument I've been given here.

1026
00:52:04,720 --> 00:52:08,760
And then go ahead and print out,
as a string, whatever is inside

1027
00:52:08,760 --> 00:52:13,890
of argv at that location here.

1028
00:52:13,890 --> 00:52:16,750
Let me fix this.

1029
00:52:16,750 --> 00:52:23,080
And let me just make it a little clearer
here, even too I could say, maybe argc

1030
00:52:23,080 --> 00:52:24,280
is--

1031
00:52:24,280 --> 00:52:25,900
and then some number.

1032
00:52:25,900 --> 00:52:31,630
And argv is, or sorry, argv-- let
me actually makes this clear--

1033
00:52:31,630 --> 00:52:37,100
so you can say "argv, bracket,
whatever we're currently looking,

1034
00:52:37,100 --> 00:52:40,190
at is whatever's inside of argv.

1035
00:52:40,190 --> 00:52:44,840
So here, when I run this program,
I'll see argv, bracket, 0, bracket,

1036
00:52:44,840 --> 00:52:47,940
1 is whatever's at that location here.

1037
00:52:47,940 --> 00:52:50,730
So I'll then go to my terminal.

1038
00:52:50,730 --> 00:52:51,600
I'll compile this.

1039
00:52:51,600 --> 00:52:53,850
I'll say, "make CLA".

1040
00:52:53,850 --> 00:52:56,220
And I'll run "/cla".

1041
00:52:56,220 --> 00:53:02,270
And now I see argv,
bracket, 0, is ./CLA.

1042
00:53:02,270 --> 00:53:07,700
But if I did ./CLA, maybe, Carter
Zenke, well now I see more.

1043
00:53:07,700 --> 00:53:10,940
I see argv, bracket, 0, is ./CLA.

1044
00:53:10,940 --> 00:53:14,600
Argv[1] is Carter. argv[2] 2 is Zenke.

1045
00:53:14,600 --> 00:53:17,930
So I've been given this array
that contains everything

1046
00:53:17,930 --> 00:53:22,290
I typed in to the terminal here.

1047
00:53:22,290 --> 00:53:26,520
Just to make this even clearer, I could
go back to this diagram over here.

1048
00:53:26,520 --> 00:53:31,390
When we "make Mario", that very
first make over here is argv[0],

1049
00:53:31,390 --> 00:53:35,400
the very first element of argv, or
argument vector, or argument list.

1050
00:53:35,400 --> 00:53:38,160
And argv[1] is that
second element there.

1051
00:53:38,160 --> 00:53:41,230
We can get using our program here.

1052
00:53:41,230 --> 00:53:44,160
And often that you'll see when you
write your own programs in CS50,

1053
00:53:44,160 --> 00:53:47,310
you might want to maybe kick off
your program with some number.

1054
00:53:47,310 --> 00:53:49,980
Maybe in Caesar, you might
type a number to help

1055
00:53:49,980 --> 00:53:52,750
us figure out how much to rotate
a certain cipher, and so on.

1056
00:53:52,750 --> 00:53:55,800
And this is helpful for actually
making our programs change behavior

1057
00:53:55,800 --> 00:53:57,355
as we go through.

1058
00:53:57,355 --> 00:53:59,730
So I just wanted to pause here
and ask for your questions

1059
00:53:59,730 --> 00:54:00,930
on command line arguments.

1060
00:54:00,930 --> 00:54:03,450
Maybe you've tried them already,
maybe you haven't, but what

1061
00:54:03,450 --> 00:54:06,750
questions do you have about why
they're used, or how we use them?

1062
00:54:06,750 --> 00:54:18,430


1063
00:54:18,430 --> 00:54:20,330
OK.

1064
00:54:20,330 --> 00:54:22,050
So seeing none so far.

1065
00:54:22,050 --> 00:54:26,600
Let's go ahead and try to do a bit
of brief exercise together here.

1066
00:54:26,600 --> 00:54:29,570
We want to write this program
called "initials", where

1067
00:54:29,570 --> 00:54:31,880
if I were to run it with
some command line arguments,

1068
00:54:31,880 --> 00:54:36,480
I would get back the initials
in the certain name here.

1069
00:54:36,480 --> 00:54:39,230
So here, I would get
back CZ, for example.

1070
00:54:39,230 --> 00:54:43,250
And notice how we have, again,
this argument vector that

1071
00:54:43,250 --> 00:54:45,720
has every element inside of it.

1072
00:54:45,720 --> 00:54:50,125
And if we want to access individual
characters inside of these strings,

1073
00:54:50,125 --> 00:54:52,250
we can just have another
bracket notation appended.

1074
00:54:52,250 --> 00:54:58,280
We could say argv[1][0] gives me that
very first element of that second

1075
00:54:58,280 --> 00:54:59,120
element in our argv.

1076
00:54:59,120 --> 00:55:05,600
And similarly, argv[2][0] gives me
that very first element of that third

1077
00:55:05,600 --> 00:55:07,490
element inside of argv.

1078
00:55:07,490 --> 00:55:11,670
So we're kind of nesting
these arrays as we go through.

1079
00:55:11,670 --> 00:55:15,090
And towards that end, let's try
to actually implement this program

1080
00:55:15,090 --> 00:55:15,640
together.

1081
00:55:15,640 --> 00:55:21,210
So we'll go over to our terminal
here and type "code initials.c".

1082
00:55:21,210 --> 00:55:22,620
And I'll do all the same stuff.

1083
00:55:22,620 --> 00:55:24,900
I'll do "include CS50.h.

1084
00:55:24,900 --> 00:55:27,180
I'll do, "include stdio.h.

1085
00:55:27,180 --> 00:55:33,210
And finally, I'll do "int main, not
void, but int argc and string argv.

1086
00:55:33,210 --> 00:55:36,190


1087
00:55:36,190 --> 00:55:40,720
I want to eventually, do
something like this, ./initials.

1088
00:55:40,720 --> 00:55:41,650
Carter Zenke.

1089
00:55:41,650 --> 00:55:46,360
So let's try printing out
first this very first C.

1090
00:55:46,360 --> 00:55:48,580
How could I print that piece out?

1091
00:55:48,580 --> 00:55:51,910
Could I ask maybe, McKenna,
if you're feeling up for it?

1092
00:55:51,910 --> 00:55:56,790
How could I try to print
out that very first C here?

1093
00:55:56,790 --> 00:56:02,250
AUDIENCE: Wouldn't you do like
printf, something having to do with

1094
00:56:02,250 --> 00:56:12,910
the argc[1][0], right?

1095
00:56:12,910 --> 00:56:14,620
CARTER ZENKE: Yeah, totally.

1096
00:56:14,620 --> 00:56:17,410
So you want to print out a character.

1097
00:56:17,410 --> 00:56:20,470
So we'd use this format code
for a character, like %c.

1098
00:56:20,470 --> 00:56:25,360
And now I have to say, OK, what
goes in this placeholder here?

1099
00:56:25,360 --> 00:56:27,760
And we could do the
following, we could say,

1100
00:56:27,760 --> 00:56:32,590
well I know I want to look inside my
argument vector, this list of strings

1101
00:56:32,590 --> 00:56:34,630
I've been given.

1102
00:56:34,630 --> 00:56:37,010
This we know is that very first one.

1103
00:56:37,010 --> 00:56:40,300
So that's argv[0].

1104
00:56:40,300 --> 00:56:44,800
This one is argv[1], which
is getting us closer.

1105
00:56:44,800 --> 00:56:48,920
But we don't want to print
out the full name here.

1106
00:56:48,920 --> 00:56:51,700
So if I were to do this, for
example, print out a string.

1107
00:56:51,700 --> 00:56:56,860
Let me do, "make initials".

1108
00:56:56,860 --> 00:56:58,840
And then run it--

1109
00:56:58,840 --> 00:57:02,120
and just a minute, oops,
let me add a semicolon.

1110
00:57:02,120 --> 00:57:09,060
Make initials, do ./initials.

1111
00:57:09,060 --> 00:57:10,380
Whoops!

1112
00:57:10,380 --> 00:57:14,000
./initials Carter Zenke.

1113
00:57:14,000 --> 00:57:15,973
Notice I get back the
full string Carter.

1114
00:57:15,973 --> 00:57:16,890
But I don't want that.

1115
00:57:16,890 --> 00:57:19,180
I just want the actual first character.

1116
00:57:19,180 --> 00:57:22,080
So I could then, as you were
saying, we go ahead and say,

1117
00:57:22,080 --> 00:57:25,170
bracket 0 to get that very
first character in there.

1118
00:57:25,170 --> 00:57:28,730
And I'll go ahead and add a /n here.

1119
00:57:28,730 --> 00:57:31,750
So I'll say, "make initials".

1120
00:57:31,750 --> 00:57:37,300
Run initials with Carter's Zenke, and
now I get backseat, which is nice.

1121
00:57:37,300 --> 00:57:40,932
But maybe to finish things out, could
we go to Bianca, if you don't mind?

1122
00:57:40,932 --> 00:57:43,390
Maybe figure out how we could
get that second initial here?

1123
00:57:43,390 --> 00:57:48,580


1124
00:57:48,580 --> 00:57:53,400
AUDIENCE: So you would
do the same thing that we

1125
00:57:53,400 --> 00:58:05,400
have instead of the one and
the zero, you would do one--

1126
00:58:05,400 --> 00:58:12,410
well, the first one, is that from the
Carter, or is that from your last name?

1127
00:58:12,410 --> 00:58:14,570
CARTER ZENKE: Yeah so
this one here, if we--

1128
00:58:14,570 --> 00:58:18,200
yeah, so when we ran
this, this is from trying

1129
00:58:18,200 --> 00:58:21,110
to get this initial C here, right?

1130
00:58:21,110 --> 00:58:22,190
AUDIENCE: Yeah.

1131
00:58:22,190 --> 00:58:23,898
CARTER ZENKE: So now
I want to get the z.

1132
00:58:23,898 --> 00:58:28,452


1133
00:58:28,452 --> 00:58:29,160
AUDIENCE: Got it.

1134
00:58:29,160 --> 00:58:34,580
OK, so you would do the same thing,
but instead of argv[1] and 0,

1135
00:58:34,580 --> 00:58:38,940
you would do two and 0.

1136
00:58:38,940 --> 00:58:40,190
CARTER ZENKE: Yeah, two and 0.

1137
00:58:40,190 --> 00:58:43,100
And the reasoning here is that
we're going to first index

1138
00:58:43,100 --> 00:58:45,950
into that argument vector
this argument list here.

1139
00:58:45,950 --> 00:58:49,460
And here, we're going to get that
third element, this index of 2

1140
00:58:49,460 --> 00:58:50,810
gives us a third element.

1141
00:58:50,810 --> 00:58:54,470
And then within this string
here, that is also an array,

1142
00:58:54,470 --> 00:58:56,550
we're going to get that
very first element.

1143
00:58:56,550 --> 00:58:58,500
So we'll go to the z here.

1144
00:58:58,500 --> 00:59:03,290
And if we do this, I would
tend to maybe make initials.

1145
00:59:03,290 --> 00:59:07,190
And then I could do
./initials, Carter Zenke.

1146
00:59:07,190 --> 00:59:11,990
I would see C, Z, and then I would
C, Z. So there's much more to this.

1147
00:59:11,990 --> 00:59:13,740
If you like, you can
maybe use a loop here

1148
00:59:13,740 --> 00:59:16,110
to go through and do multiple
Clang line arguments,

1149
00:59:16,110 --> 00:59:19,230
but I think for now,
we'll leave it here.

1150
00:59:19,230 --> 00:59:21,930
This is going to conclude
our section, officially.

1151
00:59:21,930 --> 00:59:24,600
It was wonderful to spend
time with you all today.

1152
00:59:24,600 --> 00:59:28,590
And this was CS50 for now.

1153
00:59:28,590 --> 00:59:31,570
There are also going to be labs,
tutorials and office hours this week.

1154
00:59:31,570 --> 00:59:34,960
So make sure you go to all of
those to get help as you need it.

1155
00:59:34,960 --> 00:59:36,430
I hope this was helpful for you.

1156
00:59:36,430 --> 00:59:38,805
I'm looking forward to seeing
you all throughout the term

1157
00:59:38,805 --> 00:59:41,450
and again, thank you all for
joining us on Zoom today.

1158
00:59:41,450 --> 00:59:43,000